参考链接https://www.cnblogs.com/javazhiyin/p/13839357.html

# Redis简介
Redis是高性能非关系型键值对数据库，Redis的键只能为字符串，值可以是五种数据类型：字符串、列表、集合、散列表、有序集合。
Redis的数据存放在内存中，读写速度快，每秒可以处理超过10w次读写操作。
Redis被广泛应用于缓存方向、分布式锁。Redis还支持事务，持久化等。

五种数据结构：
【string】做简单的键值对缓存
对整个字符串的其中一部分执行操作，对整数和浮点数执行自增或自减操作。
【list】存储一些列表型数据结构，类似粉丝列表、文章评论列表
从两端压入或弹出元素，对单个或多个元素进行修剪，只保留一个范围内的元素。
【set】交集、并集、差集操作
添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交、并、差集，从集合中随机获取元素。
【hash】结构化的数据，比如对象
添加、获取、移除单个键值对，检查某个键是否存在。
【zset】去重但可以排序，如获取排名前几名的用户
添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名。


# Redis应用场景
## 计数器
可以对string进行自增自减运算，从而实现计数器功能 -》 redis这种内存数据库读写性能非常高，很适合存储频繁读写的计数量。

## 缓存
将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

## 会话缓存
可以使用Redis来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。//TODO 会话缓存好想法

## 全页缓存
除基本的会话token之外，有一些插件使用redis做全页缓存，这样你就可以以最快速度加载曾经浏览过的页面。

## 查找表
例如 DNS 记录就很适合用 Redis 进行存储。-》 查找表和缓存类似，也是利用 Redis 快速的查找特性，但查找表的内容不能失效，而缓存可以失效，因为缓存不作为可靠的数据来源。

## 消息队列（发布/订阅功能）
list 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 kafka、rabbitMQ 等消息中间件。

## 分布式锁
在分布式场景下， 无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，但是 SETNX 也有陷阱，详见：单机情况https://www.jianshu.com/p/6b8b4b04f2aa 为了防止单一机器宕机，采用多台机器https://blog.csdn.net/ppvqq/article/details/46819479


# Redis常见面试题
## Redis有哪些优点
1. 读写速度快，每秒处理读写超过10w次。
2. 支持数据持久化，支持AOF和RDB两种持久化方式。 //TODO 两种持久化
3. 支持事务，Redis的所有操作都是原子性的。
4. 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

## 为什么要用Redis/缓存
高性能：
假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘读取的，将该用户访问的数据存在缓存中，这样下一次访问的时候就可以直接从缓存中获取了，从内存中读取数据会非常快。

高并发：
当数据库的访问量非常大时，可以将部分数据放入缓存中，这样一部分请求会直接访问缓存，减小数据库的压力。

## Redis为什么这么快
1. 数据存放在内存中，类似于HashMap，查找和操作的时间复杂度都是O(1)
2. 数据结构简单，都是key-value的形式，对数据操作也简单。
3. 采用单线程，避免了很多不必要的上下文切换和资源竞争，不用考虑各种锁的问题，自然不会出现死锁导致的性能消耗。

## Redis的两种持久化
第一种：RDB（默认）按照一定的时间间隔将内存中的数据以快照的形式保存到硬盘中。
优点：
1. 持久化方式方便。
2. 性能最大化，让子进程来完成持久化写操作，主进程继续处理命令。
缺点：
1. 数据安全性低，如果持久化之间redis发生故障，则会丢失数据。所以这种方式更适合数据要求不严谨的时候。

第二种：AOF，将 Redis 执行的每个写命令记录到日志文件中，当重启 Redis 时重新将持久化的日志文件恢复数据。
优点：
1. 数据安全。
2. 即使服务中途宕机，可以通过 redis-check-aof 工具解决数据一致性问题。（即比较现在的redis数据与aof中记录的是否一致）
缺点：
1. aof文件比rdb文件大，恢复速度慢。
2. 数据集大的时候，比rdb启动效率低。

## 如何选择合适的持久化方式
一般来说可以两种持久化方式都使用，当 Redis 重启时优先使用 AOF 恢复数据。
如果可以承受数分钟以内的数据丢失，那么可以使用 RDB 持久化。
如果你只希望你的数据在服务器运行的时候存在，也可以不使用任何持久化方式。

## Redis扩容问题
1. 如果是缓存，使用一致性哈希实现动态扩容缩容。
2. 如果是作为持久化存储，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。//TODO 持久化存储扩容

## Redis过期键的删除策略
三种策略，Redis中使用了惰性过期和定期过期两种过期策略。
1. 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清理。该策略会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
2. 惰性过期：只有当访问到某一个key才去判断是否过期。该策略可以最大化得节省 CPU 资源，却对内存极不友好，极端情况下会出现大量过期key没有被再次访问，从而不会被清理，占用大量内存。
3. 定期过期：这是前两个方案的折中，每隔一定时间扫描一定数量的数据库的 expires 字典中的 key。

## Redis的内存淘汰策略
Redis 的内存淘汰策略用于处理内存不足时需要申请额外空间时，并不会影响过期的key的处理。过期策略用于处理过期的缓存数据。
1. noeviction：新写入操作直接报错。
2. allkeys-lru：在键空间中移除最近最少使用的key。（最常用的策略）
3. allkeys-random：在键空间中随机移除某个key。
4. volatile-lru：在设置了过期时间的键空间中移除最近最少使用的key。
5. volatile-random：在设置了过期时间的键空间中随机移除某个key。
6. volatile-ttl：在设置了过期时间的键空间中有更早过期时间的key优先移除。
