
# Mysql 常见面试题


## 事务
事务是指作为单个逻辑工作单元执行的一系列操作，要么全执行，要么全不执行，需要满足 ACID 特性。

### 原子性（ Atomic ）
事务被视为不可分割的最小单元，事务的所有操作要么成功，要么失败回滚，不会结束在中间某个环节。

### 一致性（ Consistent ）
在事务执行前后数据库的完整性没有被破坏。这表示写入的数据必须符合所有预设规则。

### 隔离性 （ Isolation ）
允许多个事务同时执行，一个事务的执行不会影响其他事务，事务之间是隔离的。事务隔离性分为不同级别，包括读未提交、读已提交、可重复读、串行化。

### 持久性 （ Duration ）
事务一旦提交，对数据的修改是永久的，即便系统故障也不会丢失。

### MySQL 支持事务吗
在缺省模式下，MySQL 是 autocommit 模式，所有的数据库更新操作都会即时提交，所以在缺省模式下 MySQL 不支持事务。
但是如果使用 InnoDB，就可以支持事务，只要 SET AUTOCOMMIT = 0，在非 autocommit 模式下，需要使用 COMMIT 来提交更改，或者使用 ROLLBACK 来回滚更改。


***

## 隔离级别
脏读：事务可以读到未提交的数据。（针对的是事务修改后回滚，那么在此之前读到的数据称之为脏数据）
不可重复读：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。（针对事务执行过程中有修改，两次读到的数据可能不一致）
幻读：当一个事务读取某个范围内的数据时，另一个事务又在该范围内插入了新数据，当之前的事务再次读取该范围的记录时，会产生幻行。（针对范围记录，两次读取出现幻行）

### 读未提交（ Read Uncommitted ）
事务中的修改，即使没有提交，对其他事务都是可见的。

### 读已提交（ Read Committed ）
一个事务开始时，只能“看见”已经提交的事务所做的修改，解决了脏读的问题。（这是大多数数据库系统的默认隔离级别，但 Mysql 不是。）

### 可重复读（Repeated Read ）
保证了在同一个事务中多次读取同样记录结果的一致性，解决了脏读、不可重复读，但没有解决幻读。（这是 Mysql 的默认隔离级别，InnoDB 使用多版本并发控制 MVCC 机制解决了幻读的问题。）

### 可串行化（ Serializable ）
最高隔离级别，事务串行化执行，解决了幻读的问题。


****

## MVCC
MVCC 是多版本并发控制机制，通过保存数据在某个时间点的快照来实现，在每行记录后面保存两个隐藏列，分别保存这个行的创建版本号和删除版本号。MVCC 机制解决行级锁的大量开销，只有在写写时互相阻塞，使用版本控制达到读写不冲突、读不加锁、高并发。InnoDB 的 MVCC使用快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行所有快照连接起来。

### InnoDB 的 MVCC 是如何实现的
select、insert、delete、update 分类讨论：

SELECT：符合以下两点的记录才能作为查询返回结果。
1. InnoDB 只查找版本早于当前事务版本的数据行（也就是行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

INSERT：
InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。

DELETE：
InnoDB 为删除的每一行保存当前系统版本号作为删除标识。

UPDATE：
InnoDB 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。（额外空间）


***

## 锁

### 什么是锁
数据库中存在多个用户并发得存取同一个数据、多个事务并发得存取同一个数据，若不对并发操作加以控制就可能产生读取和存储不正确的数据，破坏数据库的一致性。
加锁是实现数据库并发控制的一个非常重要的技术。当某一事务释放锁之前，其他事务不能对此数据进行更新操作。

### MySql 中有哪几种锁
- 表级锁：开销小，加锁快。
- 行级锁：开销大，加锁慢，会出现死锁。

- 共享锁：读锁。
- 排他锁：写锁。

### 死锁解决
1. 死锁检测，检测循环依赖关系，让某些事务回滚。
2. 死锁超时机制，超时事务回滚。

### 死锁检测算法
//TODO 死锁检测算法

### 如何避免死锁
1. 以固定的顺序访问表和行，最常见的就是数据预处理。
2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
3. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
4. 降低隔离级别。比如将 RR 调整为 RC，可以避免掉很多因为 gap 锁造成的死锁。//TODO 举例 gap 锁造成的死锁
5. 为表添加合理的索引。

### 什么情况下 InnoDB 会使用行锁、表锁
//TODO 行锁表锁
InnoDB是基于索引来完成行锁
例: select * from tab_with_index where id = 1 for update;
for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,
如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起


***

## 索引
//TODO 索引
### 什么情况下设置了索引但无法使用
1. 以 % 开头的 LIKE 模糊匹配。
2. OR 语句前后没有同时使用索引。
3. 使用函数修饰的字段。
4. 数据类型出现隐式转化（如 varchar 不加单引号可能会自动转换为 int 型）//TODO 数据类型出现隐式转化不会使用索引

***

## 日志
//TODO 日志
### 事务日志
目的是提高事务的效率。存储引擎在修改表的数据时只需修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到磁盘上。
事务日志采用追加的方式，因此写日志的操作是在磁盘上一小块区域内的顺序 I/O，写速度快。
事务日志持久以后，内存中被修改的数据可以慢慢刷回磁盘，这种方式称为“预写式日志”，修改数据需要写两次磁盘。
如果数据的修改持久化到事务日志，但数据本身还没有写回磁盘，此时如果系统崩溃，存储引擎在重启时可以自动恢复这部分修改的数据。


***

## InnoDB
//TODO InnoDB


***

## MyISAM 与 InnoDB 的区别
//TODO MyISAM 与 InnoDB 的区别


***

## MySql 数据结构相关

### CHAR 和 VARCHAR 的区别
1. CHAR 列长度固定为创建表时声明的长度，长度值范围是1到255
2. 当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需要删除尾随空格。
3. VARCHAR 是可变长字符串

### VARCHAR(50) 中的50的涵义
最多存放50个字符，VARCHAR(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 order by col 采用 fixed_length 计算 col 的长度。

### 如果有一列被定义为TIMESTAMP，将发生什么
每当行被更改时，时间戳字段将获取当前时间戳。

### 列设置为 AUTO INCREMENT，如果在表中达到最大值，会发生什么
它会停止递增，任何进一步的插入都将产生错误。

### LIKE声明中的 % 和 _ 有什么区别
% 对应于0个或更多字符，而 _ 只匹配一个字符。

### 解释 MySQL 外连接、内连接、自然连接的区别
1. 自然连接，也称笛卡尔积，直接将两张表的所有记录一一匹配，形成n*m的大表。
2. 内连接，即有条件的自然连接，根据条件筛选出符合条件的记录，只连接匹配的行。
3. 外连接，其结果集中不仅包含符合连接条件的行，而且还包括左表、右表或两个表中所有的数据行，这三种情况依次称之为左外连接、右外连接、全外连接。
- 左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表没有匹配的记录，仍要显示，右边对应的字段值以NULL来填充。

### 完整性约束
数据完整性是指数据的精确和可靠性，分为以下四类：
1. 实体完整性：规定表的每一行在表中是唯一的实体。
2. 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等。
3. 参照完整性：是指两个表的主关键字和外关键字的数据应一致（即外键），保证了表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。
4. 用户定义的完整性：用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。

### 视图
什么是视图：

什么是游标：

视图的优点：


### 存储过程

***

## MySQL 优化相关

### MySQL 如何优化 DISTINCT
//TODO MySQL 如何优化 DISTINCT

### SQL 注入漏洞产生的原因？如何防止？
SQL 注入产生的原因：
程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。
//TODO sql 注入

### 如何保证表格里的字段值接受特定范围的值
- Check 限制，在数据库表格里被定义，用来限制输入该列的值，也可以在程序中 check。
- 触发器，可能会影响性能。

### 对 SQL 语句优化有哪些方法
//TODO SQL 语句优化

