可以参考：https://blog.csdn.net/ThinkWon/article/details/104778621
# Mysql 常见面试题


## 事务
事务是指作为单个逻辑工作单元执行的一系列操作，要么全执行，要么全不执行，需要满足 ACID 特性。

### 原子性（ Atomic ）
事务被视为不可分割的最小单元，事务的所有操作要么成功，要么失败回滚，不会结束在中间某个环节。

### 一致性（ Consistent ）
在事务执行前后数据库的完整性没有被破坏。这表示写入的数据必须符合所有预设规则。

### 隔离性 （ Isolation ）
允许多个事务同时执行，一个事务的执行不会影响其他事务，事务之间是隔离的。事务隔离性分为不同级别，包括读未提交、读已提交、可重复读、串行化。

### 持久性 （ Duration ）
事务一旦提交，对数据的修改是永久的，即便系统故障也不会丢失。

### MySQL 支持事务吗
在缺省模式下，MySQL 是 autocommit 模式，所有的数据库更新操作都会即时提交，所以在缺省模式下 MySQL 不支持事务。
但是如果使用 InnoDB，就可以支持事务，只要 SET AUTOCOMMIT = 0，在非 autocommit 模式下，需要使用 COMMIT 来提交更改，或者使用 ROLLBACK 来回滚更改。


***

## 隔离级别
脏读：事务可以读到未提交的数据。（针对的是事务修改后回滚，那么在此之前读到的数据称之为脏数据）
不可重复读：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。（针对事务执行过程中有修改，两次读到的数据可能不一致）
幻读：当一个事务读取某个范围内的数据时，另一个事务又在该范围内插入了新数据，当之前的事务再次读取该范围的记录时，会产生幻行。（针对范围记录，两次读取出现幻行）

### 读未提交（ Read Uncommitted ）
事务中的修改，即使没有提交，对其他事务都是可见的。

### 读已提交（ Read Committed ）
一个事务开始时，只能“看见”已经提交的事务所做的修改，解决了脏读的问题。（这是大多数数据库系统的默认隔离级别，但 Mysql 不是。）

### 可重复读（Repeated Read ）
保证了在同一个事务中多次读取同样记录结果的一致性，解决了脏读、不可重复读，但没有解决幻读。（这是 Mysql 的默认隔离级别，InnoDB 使用多版本并发控制 MVCC 机制解决了幻读的问题。）

### 可串行化（ Serializable ）
最高隔离级别，事务串行化执行，解决了幻读的问题。


****

## MVCC
MVCC 是多版本并发控制机制，通过保存数据在某个时间点的快照来实现，在每行记录后面保存两个隐藏列，分别保存这个行的创建版本号和删除版本号。MVCC 机制解决行级锁的大量开销，只有在写写时互相阻塞，使用版本控制达到读写不冲突、读不加锁、高并发。InnoDB 的 MVCC使用快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行所有快照连接起来。

### InnoDB 的 MVCC 是如何实现的
select、insert、delete、update 分类讨论：

SELECT：符合以下两点的记录才能作为查询返回结果。
1. InnoDB 只查找版本早于当前事务版本的数据行（也就是行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

INSERT：
InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。

DELETE：
InnoDB 为删除的每一行保存当前系统版本号作为删除标识。

UPDATE：
InnoDB 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。（额外空间）


***

## 锁

### 什么是锁
数据库中存在多个用户并发得存取同一个数据、多个事务并发得存取同一个数据，若不对并发操作加以控制就可能产生读取和存储不正确的数据，破坏数据库的一致性。
加锁是实现数据库并发控制的一个非常重要的技术。当某一事务释放锁之前，其他事务不能对此数据进行更新操作。

### MySql 中有哪几种锁
- 表级锁：开销小，加锁快。
- 行级锁：开销大，加锁慢，会出现死锁。

- 共享锁：读锁。
- 排他锁：写锁。

### 死锁解决
1. 死锁检测，检测循环依赖关系，让某些事务回滚。
2. 死锁超时机制，超时事务回滚。

### 死锁检测算法
//TODO 死锁检测算法

### 如何避免死锁
1. 以固定的顺序访问表和行，最常见的就是数据预处理。
2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
3. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
4. 降低隔离级别。比如将 RR 调整为 RC，可以避免掉很多因为 gap 锁造成的死锁。//TODO 举例 gap 锁造成的死锁
5. 为表添加合理的索引。

### 什么情况下 InnoDB 会使用行锁、表锁
//TODO 行锁表锁
InnoDB是基于索引来完成行锁
例: select * from tab_with_index where id = 1 for update;
for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,
如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起


***

## 索引
索引是 存储引擎 用于快速查找记录的一种数据结构。

### 索引的优缺点
优点：
1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和临时表。
3. 索引可以将随机 I/O 变成顺序 I/O。（IO密集型: 系统运行，大部分的状况是CPU在等 I/O(硬盘/内存)的读/写。CPU密集型: 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。 ）
缺点：
1. 创建和维护索引需要耗费时间，会降低增删改的效率，时间随数据量的增加而增加。
2. 索引需要占用物理空间。

### 索引类型
- 主键索引：数据列不允许重复，不允许为 NULL，一个表只能有一个主键。
- 唯一索引：数据列不允许重复，允许为 NULL，一个表允许多个列创建唯一索引。如 UNIQUE(column)、UNIQUE(column1, column2)
- 普通索引：没有唯一性限制，允许为 NULL，如 INDEX(column)
- 哈希索引：基于哈希表实现，。
- B-TREE索引
- 自适应哈希索引：当 InnoDB 注意到某些索引值被使用得非常频繁时，他会在内存中基于 B-TREE 索引之上再创建一个哈希索引，这是一个完全自动的内部行为，用户无法控制或配置。
- 全文索引：查找文本中的关键字，而不是直接比较索引中的值。如 FULLTEXT(column)

### 索引选择性
索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

### 前缀索引的优缺点
- 前缀索引是一种能使索引更小、更快的有效办法。
- MySQL 无法使用前缀索引做 order by 和 group by。
- 无法使用前缀索引做覆盖扫描。

### B树与B+树的比较
B树、B+树的建树过程图：https://blog.csdn.net/a2311minghan/article/details/89705532
1. 最大的区别是 B+树只有叶子节点存储数据，其余节点用来存储索引。B+树更适合用来存储外部数据，也就是磁盘数据。
2. B+树是用来作为索引的，一般来说索引很大，需要存储在磁盘上，每次在查询索引的时候，都需要把索引读到内存中，B+树的索引比B树的小很多，可以有效减少 I/O 次数，查询效率更高。
3. B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来，有利于范围查询，而范围查询其实是非常频繁的。

### B+树与哈希索引的比较
//TODO B+树与哈希索引的比较

### B+树与红黑树的比较
//TODO B+树与红黑树的比较

### 聚簇索引和非聚簇索引
![Image](/图片/聚簇索引和非聚簇索引.jpg)

InnoDB：
- 在同一个结构中保存了B-Tree索引和数据行，数据行存放于叶子结点。
- 通过主键聚集数据，如果没有定义主键，InnoDB 会选择唯一的非空索引代替，再没有，会隐式定义一个主键来作为聚簇索引。
- InnoDB 只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。
- 二级索引叶子节点存储的是主键值。
- 二级索引访问行需要两次索引查找。
- 假如 ID 是主键，二级索引列 A 上的索引就相当于索引(A, ID)，这是索引覆盖。
- 缺点：二级索引可能比想象更大，因为二级索引的叶子节点包含了引用行的主键列。

MyISAM：
- MyISAM 按照数据插入的顺序存储在磁盘上。
- MyISAM 使用前缀压缩技术使索引更小。
- 无论是主键索引还是二级索引，其叶子节点存储的是行的物理地址。

### InnoDB 二级索引的叶子节点存储的不是“行指针”，而是主键值
这样的策略减少了当出现行移动或数据页分裂时二级索引的维护工作。使用主键值当做指针会让二级索引占用更多的空间，换来的好处是，InnoDB 在移动行时无须更新二级索引中的这个“指针”。

### 为什么聚簇索引通常建议使用自增id
使用自增id 作为主键，主键是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面，当达到页的最大填充因子时，下一条记录就会写入新的页。这种方式索引结构紧凑、磁盘碎片少，不会存在也分裂，大大提高性能。
如果不使用自增id，而是乱序得写入，InnoDB 不得不频繁得做页分裂操作，这将导致移动大量数据，页会变得稀疏，数据碎片得增加最后还会使得全表扫描变慢。

### MySQL 中 B+树一个节点大小是多大
一页，MySQL 的 InnoDB 引擎中一页的默认大小为16K。

### B+树一个节点存储多少元素合适？为什么是一页？
因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，会造成资源的浪费；如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费；所以为了不造成资源的浪费，最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。

### 什么情况下设置了索引但无法使用
1. 以 % 开头的 LIKE 模糊匹配。
2. OR 语句前后没有同时使用索引。
3. 使用函数修饰的字段、或者字段在表达式中。
4. 数据类型出现隐式转化（如 varchar 不加单引号可能会自动转换为 int 型）//TODO 数据类型出现隐式转化不会使用索引

### 创建索引的原则
1. 使用最左前缀匹配。
2. 较频繁作为查询条件的字段才去创建索引。
3. 更新频繁字段不适合创建索引。（因为每次修改字段可能还得修改索引，有时还会造成页分裂。）
4. 选择性太低的列也不适合创建索引。如性别。
5. 尽量扩展索引，而不是新建索引。如已有索引a，现在需要索引(a, b)，拓展即可。
6. 对于定义为text、image、bit的数据类型的列不要建立索引。

### 百万级别或以上的数据如何删除
索引需要额外的维护成本，会降低增删改的执行效率，在百万级数据时，删除数据的速度和创建的索引数量成正比。
1. 可以先删除索引。
2. 再删除无用的数据
3. 删除完成后重建索引。

***

## 日志
//TODO 日志
### 事务日志
目的是提高事务的效率。存储引擎在修改表的数据时只需修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到磁盘上。
事务日志采用追加的方式，因此写日志的操作是在磁盘上一小块区域内的顺序 I/O，写速度快。
事务日志持久以后，内存中被修改的数据可以慢慢刷回磁盘，这种方式称为“预写式日志”，修改数据需要写两次磁盘。
如果数据的修改持久化到事务日志，但数据本身还没有写回磁盘，此时如果系统崩溃，存储引擎在重启时可以自动恢复这部分修改的数据。


***

## InnoDB
//TODO InnoDB


***

## MyISAM 与 InnoDB 的区别
//TODO MyISAM 与 InnoDB 的区别


***

## MySql 数据结构相关

### CHAR 和 VARCHAR 的区别
1. CHAR 列长度固定为创建表时声明的长度，长度值范围是1到255
2. 当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需要删除尾随空格。
3. VARCHAR 是可变长字符串

### VARCHAR(50) 中的50的涵义
最多存放50个字符，VARCHAR(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 order by col 采用 fixed_length 计算 col 的长度。

### 如果有一列被定义为TIMESTAMP，将发生什么
每当行被更改时，时间戳字段将获取当前时间戳。

### 列设置为 AUTO INCREMENT，如果在表中达到最大值，会发生什么
它会停止递增，任何进一步的插入都将产生错误。

### LIKE声明中的 % 和 _ 有什么区别
% 对应于0个或更多字符，而 _ 只匹配一个字符。

### 解释 MySQL 外连接、内连接、自然连接的区别
1. 自然连接，也称笛卡尔积，直接将两张表的所有记录一一匹配，形成n*m的大表。
2. 内连接，即有条件的自然连接，根据条件筛选出符合条件的记录，只连接匹配的行。
3. 外连接，其结果集中不仅包含符合连接条件的行，而且还包括左表、右表或两个表中所有的数据行，这三种情况依次称之为左外连接、右外连接、全外连接。
- 左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表没有匹配的记录，仍要显示，右边对应的字段值以NULL来填充。

### 完整性约束
数据完整性是指数据的精确和可靠性，分为以下四类：
1. 实体完整性：规定表的每一行在表中是唯一的实体。
2. 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等。
3. 参照完整性：是指两个表的主关键字和外关键字的数据应一致（即外键），保证了表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。
4. 用户定义的完整性：用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。

### 视图
什么是视图：

什么是游标：

视图的优点：


### 存储过程

***

## MySQL 优化相关

### MySQL 如何优化 DISTINCT
//TODO MySQL 如何优化 DISTINCT

### SQL 注入漏洞产生的原因？如何防止？
SQL 注入产生的原因：
程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。
//TODO sql 注入

### 如何保证表格里的字段值接受特定范围的值
- Check 限制，在数据库表格里被定义，用来限制输入该列的值，也可以在程序中 check。
- 触发器，可能会影响性能。

### 对 SQL 语句优化有哪些方法
//TODO SQL 语句优化

