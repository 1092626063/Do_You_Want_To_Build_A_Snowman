# 题目来源
根据同学推荐的宫水三叶学姐的题目清单从“简单->中等->困难”的顺序来刷题，目标是巩固及保持题感。

链接：https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E4%BA%8C%E5%88%86

# 两大模板
模板一：向上取整
```c++
while(L<R)              
{
    mid=(L+R+1)/2;      //上取整的板子 
    if(f(mid)>=S)       //这边到底取不取等号，依据题目而定，保证最终L是有效的
        L=mid;      
    else
        R=mid-1;      //最终L和R必相等，不会死循环
}
```

模板二：向下取整
```c++
while(L<R)                    
{
    mid=(L+R)/2;      //下取整的板子 
    if(f(mid)<S)      //这边取不取等号也是依据题目而定，保证最终的L是有效的
        R=mid;      
    else
        L=mid+1;      //最终L和R必相等，不会死循环
} 
```

# 使用二分的函数
```c++
lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 
upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。
```

# 简单8题（2021.11.11）
35. 搜索插入位置
278. 第一个错误的版本
367. 有效的完全平方数
374. 猜数字大小
441. 排列硬币
704. 二分查找
852. 山脉数组的峰顶索引
1337. 矩阵中战斗力最弱的 K 行 ★（力求找到最优解，相较于朴素解法，此题有好多可以优化之处。ps：优先队列中如果存的是pair，则默认对第一个进行排序，再对第二个排序。）

心得：
简单题暴露出一个问题，二分的逻辑没有问题，但是二分数组的边界情况往往被忽视，引起重视。
