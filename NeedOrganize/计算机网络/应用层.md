# HTTP和HTTPS的区别

1. HTTP 协议是以明文的方式在网络中传输数据，而 HTTPS 协议传输的数据则是经过 SSL/TLS 加密后的，HTTPS 具有更高的安全性

2. HTTPS 在 TCP 三次握手阶段之后，还需要进行 SSL 的 handshake，协商加密使用的对称加密密钥

   > SSL的handshake：
   >
   > 1. 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
   > 2. 服务器端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
   > 3. 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器端。
   > 4. 服务器端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。
   > 5. 客户端和服务器端根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

3. HTTPS 协议需要服务端申请证书，浏览器端安装对应的根证书

4. HTTP 协议端口是 80，HTTPS 协议端口是 443
# HTTPS优点
HTTPS 传输数据过程中使用密钥进行加密，所以安全性更高
HTTPS 协议可以认证用户和服务器，确保数据发送到正确的用户和服务器

# HTTPS缺点
**HTTPS 握手阶段延时较高**：由于在进行 HTTP 会话之前还需要进行 SSL 握手，因此HTTPS 协议握手阶段延时增加
**HTTPS 部署成本高**：一方面 HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买 CA证书；另一方面由于采用 HTTPS 协议需要进行加解密的计算，占用 CPU 资源较多，需要的服务器配置或数目高
**HTTPS 消耗较多的 CPU 资源：**非对称加密算法不是简单的位运算，它涉及到大数乘法、大数模等等运算，相对比较复杂，消耗较高的 CPU 资源。

# HTTP协议

## http简介

HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。
HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）。
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW中使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG（Next Generation of HTTP）的建议已经提出。
HTTP 协议工作于客户端-服务端架构之上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。

## http协议特点

1. 简单快速：
客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
2. 灵活：
HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
3. 无连接：
无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4. 无状态：
HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
5. 支持B/S及C/S模式。
6. 默认端口80。
7. 基于TCP协议。

## http之URL

http使用统一资源标识符（URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。

URL，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。

例：

`http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name`

从上面的URL可以看出，一个完整的URL包括以下几部分：

1. 协议部分：该URL的协议部分为`http:`，这代表网页使用的是HTTP协议。
2. 域名部分：该URL的域名部分为`www.aspxfans.com`。一个URL中，也可以使用IP地址作为域名使用。
3. 端口部分：跟在域名后面的是端口，域名和端口之间使用`:`作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口。
4. 虚拟目录部分：从域名的第一个`/`到最后一个`/`为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。
5. 文件名部分：从域名的最后一个`/`开始到`?`为止，是文件名部分，如果没有`?`，则是从域名的最后一个`/`开始到`#`为止，是文件部分，如果没有`?`和`#`，那么从域名后的最后一个`/`开始到结束，都是文件名部分。
6. 锚部分：从`#`开始到最后，都是锚部分。
7. 参数部分：从`?`开始到`#`为止之间的部分。

## URI和URL的区别

### URI（统一资源标识符）

统一资源标识符用来唯一地标识一个资源。

Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个URI来定位的。

URI一般由三部组成：
①访问资源的命名机制
②存放资源的主机名
③资源自身的名称，由路径表示，着重强调于资源

### URL（统一资源定位器）

它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

URL是Internet上用来描述信息资源的字符串，主要用在各种www客户程序和服务器程序上，特别是著名的Mosaic。

采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。

URL一般由三部组成：
①协议(或称为服务方式)
②存有该资源的主机IP地址(有时也包括端口号)
③主机资源的具体地址。如目录和文件名等

### URN（统一资源命名）

通过名字来表示资源，比如`mailto:java-net@java.sun.com`。

URI是以一种抽象的抽象的、高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。

## HTTP之请求消息Request

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

请求行、请求头部、空行和请求数据。

![image-20201130141507593](D:\notes\面试准备\计算机网络\应用层.assets\image-20201130141507593.png)

请求行以一个方法符号开头，以空格分开，后面跟着请求的URL和协议的版本。

请求方法：

Get方法用于发送请求获得服务器资源。
Post方法用于向服务器提交数据。
Put方法用于更新服务器上指定的资源。

Get请求例子：

```
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com   //请求资源所在的服务器
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36  
			//客户端使用的操作系统和浏览器的名称和版本。
Accept    image/webp,image/*,*/*;q=0.8  //支持响应的数据类型。
Referer    http://www.imooc.com/        //先前网页的地址，表示请求来自哪里。
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8

```

第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本。

第二部分：请求头部，用来说明服务器要使用的附加信息。

HOST将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础。该信息由浏览器定义，并且在每个请求中自动发送。

> **Host：**
>
> 客户端发送请求时，用来指定服务器的域名。
>
> 有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。
>
> ![640](D:\notes\面试准备\计算机网络\应用层.assets\640.webp)
>
> **Content-Length：**
>
> 服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。
>
> **Connection：**
>
> `Connection` 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。
>
> HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。
>
> **Content-Type：**
>
> `Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。
>
> 上面的类型表明，发送的是网页，而且编码是UTF-8。
>
> 客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。
>
> `Content-Type: text/html; charset=utf-8`
>
> **content-Encoding：**
>
> `Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。
>
> `Content-Encoding: gzip`
>
> 上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。
>
> 客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。
>
> `Accept-Encoding: gzip, deflate`

第三部分：空行，请求头部后面的空行是必须的。

第四部分：请求数据也叫主体，可以添加任意的其他数据。

这个例子的请求数据为空。

POST请求例子：

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

第一部分：请求行，第一行明了是post请求，以及http1.1版本。

第二部分：请求头部，第二行至第六行。

第三部分：空行，第七行的空行。

第四部分：请求数据，第八行。



Get和Post的区别：
Get用于获取资源信息，而Post用于更新资源信息，Get请求的数据实体会放在URL后面，用？分割，这样的话，参数暴露其实不太安全。



Cookie和Session的区别：
Cookie保存在客户端，Session保存在服务端，Cookie的缺点是大小和数量都有限制，如果太大每次请求都要带上，影响了传输效率，Session是基于Cookie实现的。



## HTTP之响应消息Response

一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。

HTTP响应也由四个部分组成，分别是：状态行、响应消息报头、空行和响应正文。

例：

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

第一部分：状态行，由HTTP协议版本号、状态码、状态消息三部分组成。

第二部分：消息报头，用来说明客户端要使用的一些附加信息

第二行和第三行为消息包头。

Date：生成相应的日期和时间；

Content-Type：指定了MIME类型的HTML（text/html），编码类型是UTF-8

第三部分：空行，消息报头后面的空行是必须的。

第四部分：响应正文，服务器返回给客户端的文本信息。

## HTTP之状态码

HTTP 协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：

* 1xx：指示信息——表示请求已接收，继续处理。
  * 100 Continue：继续，客户端应继续其请求
  * 101 Switching Protocols：切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议

* 2xx：成功——表示请求已被成功接收、理解、接受。
  * 200 OK：客户端请求成功。
  * 206 partial content：服务器已经正确处理部分 GET 请求，实现断点续传或同时分片下载，该请求必须包含 Range 请求头来指示客户端期望得到的范围。

* 3xx：重定向——要完成请求必须进行更进一步的操作。
  * 300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。
  * 301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个 URI 之一。
  * 302 move temporarily(临时重定向)：请求的资源现在临时从不同的 URI 中获得。
  * 304 not modified：如果客户端发送一个待条件的 GET 请求并且该请求已经被允许，而文档内容未被改变，则返回 304,该响应不包含包体（即可直接使用缓存）。
* 4xx：客户端错误——请求有语法错误或请求无法实现。
  * 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
  * 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
  * 403 Forbidden：服务器收到请求，但是拒绝提供服务。
  * 404 Not Found：请求资源不存在，举个例子：输入了错误的 URL。
  * 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时。

* 5xx：服务器端错误——服务器未能实现合法的请求。
  * 500 Internal Server Error：服务器发生不可预期的错误。
  * 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。
  * 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求。

## HTTP请求方法

根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP1.0定义了三种请求方法：GET、POST和HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE和CONNECT方法。

GET：请求指定的页面信息，并返回实体主体。
HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。
POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT：从客户端向服务器传送的数据取代指定的文档的内容。
DELETE：请求服务器删除指定的页面。
CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS：允许客户端查看服务器的性能。
TRACE：回显服务器收到的请求，主要用于测试或诊断。

> **GET和POST的区别：**
>
> `Get` 方法的含义是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。
>
> 而`POST` 方法则是相反操作，它向 `URI` 指定的资源提交数据，数据就放在报文的 body 里。
>
> **GET和POST方法都是安全和幂等的吗？**
>
> 先说明下安全和幂等的概念：
>
> - 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
> - 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
>
> 那么很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
>
> **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

## HTTP工作原理

HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP请求/相应的步骤如下：

1. 客户端连接到Web服务器：
   一个HTTP 客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.baidu.com。
2. 发送HTTP请求：
   通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
3. 服务器接受请求并返回HTTP响应
   Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
4. 释放连接TCP连接
   若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。
5. 客户端浏览器解析HTML内容
   客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

> 举例：
> 在浏览器地址栏键入 URL，按下回车之后会经历以下流程：
>
> 1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；
> 2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接；
> 3. 浏览器发出读取文件（URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为TCP 三次握手的第三个报文的数据发送给服务器；
> 4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；
> 5. 释放 TCP 连接；
> 6. 浏览器将该 html 文本并显示内容。

## GET和POST请求的区别

Get请求：

```
GET /books/?sex=man&name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive

```

POST请求：

```
POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

1. GET提交：

   请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以`?`分割URL和传输数据，多个参数用`&`连接。例如`login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD`。如果数据是英文字母/数字，原样发送，如果是空格，转换为`+`，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。

   POST提交：

   把提交的数据放置在HTTP包的包体中。

   **因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。**

2. 传输数据的大小：

   HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。

   而在实际开发中存在的限制主要有：

   GET：特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节（2K+35）。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。

   POST：由于不是通过URL传值，理论上数据不受限。但实际各个web服务器会规定对POST提交数据大小进行限制，Apache、IIS6都有各自的配置。

3. 安全性：

   POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史记录，那么别人就可能拿到你的账号密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。

4. 对于 GET 方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。因此，**GET产生一个TCP数据包，POST产生两个TCP数据包。**

5. get 请求只能进行 url 编码，而 post 支持多种编码方式。

7. GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

## HTTP1.0、HTTP1.1和HTTP2.0的区别

### HTTP1.0和HTTP1.1的区别

1. **长连接**

   HTTP1.0协议使用非持久连接，即在非持久连接下，一个tcp连接只传输一个Web对象。

   HTTP1.1支持持久连接，也就是说长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

   一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP1.1还允许客户端不用等待上一次请求返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的**先后顺序**依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

   > HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
   >
   > 什么是keep-alive模式？
   >
   > 我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。
   >
   > http1.0中默认是关闭的，需要在http头加入**"Connection: Keep-Alive"**，才能启用Keep-Alive；http1.1中默认启用Keep-Alive，如果加入**"Connection: close"**，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。

2. **管道网络传输**

   HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

   即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

   举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。

   ![640 (1)](D:\notes\面试准备\计算机网络\应用层.assets\640 (1).webp)

   但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

3. 队头阻塞

   「请求 - 应答」的模式加剧了 HTTP 的性能问题。

   因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」。**好比上班的路上塞车**。

   ![640 (2)](D:\notes\面试准备\计算机网络\应用层.assets\640 (2).webp)

### HTTP2.0和HTTP1.X相比的特性

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

* **二进制格式**

  HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式。**

  头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧和数据帧**。

  ![640 (3)](D:\notes\面试准备\计算机网络\应用层.assets\640 (3).webp)

  这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这**增加了数据传输的效率**。

* **数据流**

  HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

  每个请求或回应的所有数据包，称为一个数据流（`Stream`）。

  每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数

  客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。

  ![640 (4)](D:\notes\面试准备\计算机网络\应用层.assets\640 (4).webp)

* **多路复用**

  HTTP/2 是可以在**一个连接中并发多个请求或回应，而不用按照顺序一一对应**。

  移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，**降低了延迟，大幅度提高了连接的利用率**。

  举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

  ![640 (5)](D:\notes\面试准备\计算机网络\应用层.assets\640 (5).webp)

* **header压缩**

  HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的分**。

  这就是所谓的 `HPACK` 算法：**在客户端和服务器同时维护一张头信息表**，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。

  **使用Huffman编码对首部进行压缩。**

* **服务端推送**

  HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。
  
  举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送（Server Push，也叫 Cache Push）。

### HTTP3.0和HTTP2.0相比的特性

HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。

所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

- HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

![640 (13)](D:\notes\面试准备\计算机网络\应用层.assets\640 (13).webp)

UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。

大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。

- QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，**其他流不会受到影响**。
- TL3 升级成了最新的 `1.3` 版本，头部压缩算法也升级成了 `QPack`。
- HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 `TLS/1.3` 的三次握手。QUIC 直接把以往的 TCP 和 `TLS/1.3` 的 6 次交互**合并成了 3 次，减少了交互次数**。

![640 (14)](D:\notes\面试准备\计算机网络\应用层.assets\640 (14).webp)

所以， QUIC 是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议。

QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。

# ==HTTPS协议==

## Why HTTPS

但是，HTTP 有着一个致命的缺陷，那就是内容是**明文传输**的，没有经过任何加密，而这些明文数据会经过**WiFi、路由器、运营商、机房**等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，这一攻击手法叫做MITM（Man In The Middle）**中间人**攻击。

> 回忆一下几年前遍地都是的**运营商劫持**，当你访问一个本来很正常的网页，但页面上却莫名其妙出现了一些广告标签、跳转脚本、欺骗性的红包按钮，甚至有时候本来要下载一个文件，最后下下来却变成了另外一个完全不同的东西，这些都是被运营商劫持了HTTP明文数据的现象。
>
> ![image-20201130151046444](D:\notes\面试准备\计算机网络\应用层.assets\image-20201130151046444.png)
>
> 还有各大公司的员工**安全培训**里都有一条「不要连陌生的WiFi」，也是类似的原因，恶意WiFi的控制者可以看到和篡改HTTP明文传输的信息。

为了解决HTTP明文传输数据可能导致的安全问题，1994年网景公司提出了HTTPS（HyperText Transfer Protocol Secure）超文本传输安全协议，数据通信仍然是HTTP，但利用**SSL/TLS加密数据包**。

## HTTPS实现原理

SSL（Secure Sockets Layer）安全套接层和TLS（Transport Layer Security）传输层安全协议其实是一套东西。

网景公司在1994年提出HTTPS协议时，使用的是SSL进行加密。后来IETF（Internet Engineering Task Force）互联网工程任务组将SSL进一步标准化，于1999年公布第一版TLS协议文件TLS 1.0。目前最新版的TLS协议是TLS 1.3，于2018年公布。

### 工作流程

我们先来看看HTTPS的加解密流程。

![HTTPS加解密流程](D:\notes\面试准备\计算机网络\应用层.assets\17126e3d3922763b.jpg)

1. 用户在浏览器发起HTTPS请求，默认使用服务器端的443端口进行连接；
2. HTTPS需要使用一套**CA数字证书**，证书内会附带一个公钥Pub，而与之对应的**私钥Private**保留在服务器端不公开；
3. 服务器端收到请求，返回配置好的包含**公钥Pub**的证书给客户端；
4. 客户端收到**证书**，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的**随机Key**，并用证书内的**公钥Pub**进行加密，发送给服务器端；
6. 服务器端收到**随机Key**的密文，使用与**公钥Pub**配对的**私钥Private**进行解密，得到客户端真正想发送的**随机Key**；
7. 服务器端使用客户端发送过来的**随机Key**对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用**随机Key**对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的**随机Key**进行对称加解密。

### 对称加密与非对称加密

对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。如果通信双方都持有密钥，且天知地知你知我知，绝对不会有别的人知道，那么通信安全自然是可以得到保证的（在**密钥足够强**的情况下）。

然而，在HTTPS的传输场景下，服务端事先并不知道客户端是谁，你也**不可能在事先不通过互联网和每一个网站的管理员都悄悄商量好一个通信密钥**出来，那么必然存在一个密钥在互联网上传输的过程，如果在传输过程中被别人监听到了，那么后续的所有加密都是无用功。

这时，我们就需要另一种神奇的加密类型，非对称加密。

非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。

那么，当客户端发起连接请求，服务端将公钥传输过去，客户端利用公钥加密好信息，再将密文发送给服务器端，服务器端里有私钥可以解密。

但是，当服务端要返回数据，如果用公钥加密，那么客户端并没有私钥用来解密，而如果用私钥加密，客户端虽然有公钥可以解密，但这个公钥之前就在**互联网上传输过**，很有可能已经有人拿到，所以这一过程只用非对称加密是不能满足的。

> 注意，严格来讲，私钥并不能用来加密，只能用作签名使用，这是由于密码学中生成公钥私钥时对不同变量的数学要求是不同的，因此公钥私钥抵抗攻击的能力也不同，在实际使用中不可互换。签名的功能在HTTPS里也有用到。

只有一组公钥私钥只能保证单程的加解密，那么如果我们准备两组公钥私钥呢，是不是可以解决这个问题？来看下面这个过程。

1. 服务器端有非对称加密的公钥A1，私钥A2；
2. 客户端有非对称加密的公钥B1，私钥B2；
3. 客户端向服务器端发起请求，服务器端将公钥A1返回给客户端；
4. 浏览器收到公钥A1，将自己保存的公钥B1发送给客户端；
5. 之后服务器端所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密；
6. 客户端所有向服务器端发送的数据，使用公钥A1加密，服务器端可以使用私钥A2解密。

此时，两条传输方向的数据都经过非对称加密，都能保证安全性，那么为什么不采用这种方式呢？

最主要的原因是**非对称加解密耗时要远大于对称加解密**，对性能有很大损耗，大家的使用体验很差。

> ==为什么非对称加密比对称加密慢？==
>
> 因为对称加密主要的运算是**位运算**，速度非常快。以AES算法为例，如下图所示，其运算本质上来说就是位移和替换。
>
> ![5666077-7e8b569ab9ac81b3](D:\notes\面试准备\计算机网络\应用层.assets\5666077-7e8b569ab9ac81b3.png)
>
> 但是非对称加密计算一般都比较复杂，比如RSA，它里面涉及到大数乘法、大数模等等运算。其加解密可以用下面的公式来表示：
>
> $密文=明文^E mod N$
>
> $明文=密文^D mod N$
>
> 当然，我想另外还有一个原因是，AES 中的许多中间计算过程是可以事先计算好的。加密数据时许多中间过程可以直接查表，而不需要实时地计算。
>
> 对于密钥的存储情况也是这样吗？非对称加密对于密钥的存储会比对称加密的密钥存储少吗？
> 答案是的确如此，在对称加密中，当信息量大的时候，要求密钥量也要足够大，需要每两个人之间都有一个密钥，也就是对于n个人来说，一共需要n(n-1)/2个密钥才能确保两两之间对话不被其他人知道。
> 而在非对称加密中，每个人都有公钥和私钥，对于n个人来说，一共要2n个密钥，就能保证两两之间对话不被其他人知道。
>
> 这么看，非对称加密虽然效率低下，但是存储成本低且相对安全，这也就解释了为什么非对称加密应用如此广泛了。

所以，我们才最终选用了上文介绍到的非对称加密+对称加密的方案，再复习一下：

1. 服务器端有非对称加密的公钥A1，私钥A2；
2. 客户端发起请求，服务器端将公钥A1返回给客户端；
3. 客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务器端；
4. 服务器端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题；
5. 之后双方通信都使用密钥K进行对称加解密。

看起来是一个非常完美的方法，**兼顾**了安全性和性能，但是，真的就安全了么？

### CA颁发机构

依然考虑**中间人攻击**的情况，非对称加密的算法都是**公开**的，所有人都可以自己生成一对公钥和私钥。

当服务器端向客户端返回公钥A1的时候，中间人将其**替换**成自己的公钥B1传送给浏览器。

而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被**中间人截获**，中间人利用自己的私钥B2解密，得到密钥K，再使用服务器端的公钥A1加密传送给服务器端，完成了通信链路，而服务器端和客户端毫无感知。

![HTTPS中间人](D:\notes\面试准备\计算机网络\应用层.assets\17126e3d6f9ececf.jpg)

出现这一问题的核心原因是**客户端无法确认收到的公钥是不是真的是服务器端发来的**。为了解决这个问题，互联网引入了一个公信机构，这就是CA。

服务器端在使用HTTPS前，去经过认证的CA机构申请颁发一份**数字证书**，数字证书里包含有证书持有者、证书有效期、公钥等信息，服务器端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。

但是，如果中间人也聪明一点，**只改动了证书中的公钥部分**，客户端依然不能确认证书**是否被篡改**，这时我们就需要一些防伪技术了。

前面说过，非对称加密中一般公钥用来加密，私钥用来解密，虽然私钥加密理论上可行，可由于数学上的设计这么做并不适合，那么私钥就只有解密这个功能了么？

私钥除了解密外的真正用途其实还有一个，就是**数字签名**，其实就是一种防伪技术，只要有人篡改了证书，那么数字签名必然校验失败。具体过程如下：

1. CA机构拥有自己的一对公钥和私钥；
2. CA机构在颁发证书时对证书明文信息进行哈希；
3. 将哈希值用私钥进行**加签**，得到数字签名。

**明文数据和数字签名组成证书，传递给客户端。**

1. 客户端得到证书，分解成明文部分Text和数字签名Sig1；
2. 用CA机构的公钥进行**解签**，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）
3. 用证书里声明的哈希算法对明文Text部分进行哈希得到T；
4. 当自己计算得到的哈希值T与**解密**后的Sig2**相等**，表示证书可信，**没有被篡改**。

这时，签名是由CA机构的私钥生成的，中间人篡改信息后无法拿到CA机构的私钥，保证了证书可信。

在这个过程中，系统或浏览器中内置的CA机构的证书和公钥成为了至关重要的环境，这也是CA机构公信身份的证明，如果系统或浏览器中没有这个CA机构，那么客户端可以不接受服务器端传回的证书，显示HTTPS警告。

实际上CA机构的证书是一条信任链，A信任B，B信任C，以**掘金的证书**为例，掘金向RapidSSL申请一张证书，而RapidSSL得CA身份是由DigiCert Global根CA认证的，构成了一条信任链。

各级CA机构的私钥是绝对的私密信息，一旦CA机构的私钥泄露，其公信力就会一败涂地。之前就有过几次**CA机构私钥泄露**，引发信任危机，各大系统和浏览器只能纷纷吊销内置的对应CA的根证书。

有些老旧的网站会要求使用前下载安装他自己的根证书，这就是这个网站使用的证书并不能在系统内置的CA机构和根证书之间形成一条信任链，需要自己安装根证书来构成信任链，这里的风险就要**使用者自己承担**了。

# http协议会话结束标志怎么看出来
看tcp连接是否有断开的四次挥手阶段。

