# socket 的开发？具体网络层的操作该怎么做？
服务端：socket-bind-listen-accept
客户端：socket-connect
# server 端监听端口，但还没有客户端连接进来，此时进程处于什么状态？
这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了 epoll,select 等这样的 io 复用情况下，处于运行状态。
# socket 编程中服务器端和客户端主要用到哪些函数
基于TCP的socket：
* 服务器端程序：
1. 创建一个 socket，用函数 socket()
2. 绑定 IP 地址、端口等信息到 socket 上，用函数 bind()
3. 设置允许的最大连接数，用函数 listen()
4. 接收客户端上来的连接，用函数 accept()
5. 收发数据，用函数 send()和 recv()，或者 read()和 write()
6. 关闭网络连接
* 客户端程序：
1. 创建一个 socket，用函数 socket()
2. 设置要连接的对方的 IP 地址和端口等属性
3. 连接服务器，用函数 connect()
4. 收发数据，用函数 send()和 recv()，或 read()和 write()
5. 关闭网络连接
![[Pasted image 20201124155640.png]]
基于 UDP 的 socket：
* 服务器端程序：
1. 建立套接字文件描述符，使用函数 socket()，生成套接字文件描述符。
2. 设置服务器地址和侦听端口，初始化要绑定的网络地址结构。
3. 绑定侦听端口，使用 bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。
4. 接收客户端的数据，使用 recvfrom()函数接收客户端的网络数据。
5. 向客户端发送数据，使用 sendto()函数向服务器主机发送数据。
6. 关闭套接字，使用 close()函数释放资源。
* 客户端程序：
1. 建立套接字文件描述符，socket()。
2. 设置服务器地址和端口，struct sockaddr。
3. 向服务器发送数据，sendto()。
4. 接收服务器的数据，recvfrom()。
5. 关闭套接字，close()。

# UDP的connect函数（看不懂）
除非套接字已连接，否则异步错误是不会反悔到 UDP 套接字的。我们确实可以给 UDP 套接字调用 connect，然而这样做的结果却与 TCP 连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的 IP 地址和端口号，然后立即返回调用进程。
对于已连接 UDP 套接字，与默认的未连接 UDP 套接字相比，发生了三个变化。
其实一旦 UDP 套接字调用了 connect 系统调用，那么这个 UDP 上的连接就变成一对一的连接，但是通过这个 UDP 连接传输数据的性质还是不变的，仍然是不可靠的 UDP 连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用 TCP 那一套系统调用了。
1. 我们再也不能给输出操作指定目的 IP 地址和端口号。也就是说，我们不使用 sendto，而改用 write 或 send。写到已连接 UDP 套接字上的任何内容都自动发送到由 connect 指定的协议地址。可以给已连接的 UDP 套接字调用 sendto，但是不能指定目的地址。sendto 的第五个参数必须为空指针，第六个参数应该为 0。
2. 不必使用 recvfrom 以获悉数据报的发送者，而改用 read、recv 或 recvmsg。在一个已连接 UDP 套接字上，由内核为输入操作返回的数据报只有那些来自 connect 指定协议地址的数据报。这样就限制一个已连接 UDP 套接字能且仅能与一个对端交换数据报。
3. 由已连接 UDP 套接字引发的异步错误会返回给它们所在的进程，而未连接的 UDP 套接字不接收任何异步错误。

来自任何其他 IP 地址或断开的数据报不投递给这个已连接套接字，因为它们要么源 IP 地址要么源 UDP 端口不与该套接字 connect 到的协议地址相匹配。
UDP 客户进程或服务器进程只在使用自己的 UDP 套接字与确定的唯一对端进行通信时，才可以调用 connect。调用 connect 的通常是 UDP 客户，不过有些网络应用中的 UDP 服务器会与单个客户长时间通信 TFTP，这种情况下，客户和服务器都可能调用 connect。
# Socket 编程的 send() recv() accept() socket()函数（实践之后再看）
send 函数用来向 TCP 连接的另一端发送数据。客户程序一般用 send 函数向服务器发送请求，而服务器则通常用 send 函数来向客户程序发送应答,send 的作用是将要发送的数据拷贝到缓冲区，协议负责传输。
recv 函数用来从 TCP 连接的另一端接收数据，当应用程序调用 recv 函数时，recv 先等待 s 的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。
accept 函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept 函数阻塞，不为空的时候 accept 函数从上边取下来一个已完成连接，返回一个文件描述符。
