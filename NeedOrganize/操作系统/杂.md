# 字节序

## 主机字节序

### 概念

主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：

- 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址（这是人类读写数值的方法）
- 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址

## 存储方式

32 位整数 `0x12345678` 是从起始位置为 `0x00` 的地址开始存放，则：

| 内存地址 | 0x00 | 0x01 | 0x02 | 0x03 |
| -------- | ---- | ---- | ---- | ---- |
| 大端     | 12   | 34   | 56   | 78   |
| 小端     | 78   | 56   | 34   | 12   |

![CPU-Big-Endian.svg](D:\notes\面试准备\操作系统\杂.assets\CPU-Big-Endian.svg.png)

![CPU-Little-Endian.svg](D:\notes\面试准备\操作系统\杂.assets\CPU-Little-Endian.svg.png)

### 各架构处理器的字节序

- x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；
- Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；
- ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。

### ==如何判断用的是什么字节序==

下面的这段代码可以用来判断计算机是大端的还是小端。

**判断的思路是：**确定一个多字节的值（下面使用的是4字节的整数），将其写入内存（即赋值给一个变量），然后用指针取其首地址所对应的字节（即低地址的一个字节），判断该字节存放的是高位还是低位，高位说明是Big endian，低位说明是Little endian。

```C++
int i=0x12345678;
if(*((char*)&i)==0x12)
    cout<<"大端"<<endl;
else
    cout<<"小端"<<endl;
```

## 网络字节序

网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。

网络字节顺序采用：大端（Big Endian）排列方式。

