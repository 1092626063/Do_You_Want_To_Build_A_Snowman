# 中断概念
中断是指 CPU 对系统发生的某个事件做出的一种反应，CPU 暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由 CPU 外部引起的，如 I/O 中断、时钟中断，一种是来自 CPU 内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出，最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。

# 用户态和内核态

![v2-d3723a14f07a42c7e016ae9bc38eddef_720w](D:\notes\面试准备\操作系统\中断.assets\v2-d3723a14f07a42c7e016ae9bc38eddef_720w.jpg)

**系统调用**将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。

内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。

用户态：提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**

## 用户态到内核态的转化原理

1. 系统调用

   这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 Linux 的 ine 80h 中断。

2. 异常

   当 CPU 在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。

3. 外围设备的中断

   当外围设备完成用户请求的操作之后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

# 系统调用和函数调用的区别

## 系统调用

系统调用指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。它通过软中断向内核态发出一个明确的请求。系统调用实现了用户态进程和硬件设备之间的大部分接口。

系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。下面适用于访问设备驱动程序的系统调用:

> open: 打开文件或设备
> read: 从打开的文件或设备中读取数据
> write: 向打开的文件或设备中写入数据
> close: 关闭文件或设备
> ioctl: 把控制信息传递给设备驱动文件

用户进程需要发生系统调用时，内核将调用内核相关函数来实现（如sys_read(),sys_write(),sys_fork()）。用户程序不能直接调用这些函数，这些函数运行在内核态，CPU 通过软中断切换到内核态开始执行内核系统调用函数。

> 用户态–>系统调用–>内核态–>返回用户态

实际上使用系统调用会影响系统的性能，在执行调用时的从用户态切换到内核态，再返回用户态会有系统开销。为了减少开销，因此需要减少系统调用的次数，并且让每次系统调用尽可能的完成多的任务。硬件也会限制对底层系统调用一次所能写的数据块的大小。为了给设备和文件提供更高层的接口，Linux系统提供了一系列的标准函数库。使用标准库函数，可以高效的写任意长度的数据块，库函数在数据满足数据块长度要求时安排执行底层系统调用。

## 库函数

库函数用于提供用户态服务。它可能调用封装了一个或几个不同的系统调用（printf调用write），也可能直接提供用户态服务（atoi不调用任何系统调用）。

![0](D:\notes\面试准备\操作系统\中断.assets\0.jfif)

## 区别

1. **系统调用通常不可替换，而库函数通常可替换**

   普通的库函数调用由函数库或用户自己提供，因此库函数是可以替换的。例如，对于存储空间分配函数malloc，如果不习惯它的操作方式，我们完全可以定义自己的malloc函数。

2. **系统调用通常提供最小接口，而库函数通常提供较复杂功能**

   例如sbrk系统调用分配一块空间给进程，而malloc则在用户层次对这以空间进行管理。

3. **系统调用运行在内核空间，而库函数运行在用户空间**

   因为系统调用属于内核，和库函数不属于内核。因此，如果当用户态进程调用一个系统调用时，CPU需要将其切换到内核态，并执行一个内核函数。

4. **内核调用都返回一个整数值，而库函数并非一定如此**

   在内核中，整数或0表示系统调用成功结束，而负数表示一个出错条件。而出错时，内核不会将其设置在errno，而是由库函数从系统调用返回后对其进行设置或使用。

5. **使用库函数的移植性较系统调用更好。**

   系统调用依赖于内核，不保证移植性。库函数平台移植性好。

6. **系统调用运行时间属于系统时间，库函数运行时间属于用户时间**

7. **调用系统调用开销相对库函数来说更大**

   很多库函数本身都调用了系统调用，那为什么直接调用系统调用的开销较大呢？这得益于双缓冲的实现，在用户态和内核态，都应用了缓冲技术，对于文件读写来说，调用库函数，可以大大减少调用系统调用的次数。而用户进程调用系统调用需要在用户空间和内核空间进行上下文切换，开销较大。如此以来，库函数的开销也就会比直接调用系统调用小了。另外一方面，库函数同样会对系统调用的性能进行优化。

