# 事务
数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。要满足 ACID 特性。
事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的 ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由 DBMS 中的事务管理子系统负责事务的处理。

# ACID
原子性（Atomic）、一致性（Consistent）、隔离性（Isolation）、持久性（Duration），简称ACID。
## 原子性
事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。
## 一致性
数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。
## 隔离性
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

> |  Isolation Level   | 脏读（Dirty Read） | 不可重复读（Non Repeatable Read）| 幻读（Phantom Read）|
|  ----  | ----  | ---- | ---- |
| Read Uncommitted  | Yes | Yes | Yes |
| Read Committed  | - | Yes | Yes |
| Repeatable Read | - | - | Yes|
| Serializable | - | - | - |
> **脏读：**一个事务读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据。
> **不可重复读：**在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。
> **幻读：**在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。
> **隔离级别：**
> **Read Uncommitted（读取未提交内容）：**最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。
> **Read Committed（读取提交内容）：**只有在事务提交后，其更新结果才会被其他事务看见。可以解决**脏读**问题。
> **Repeated Read（可重复读）：**在一个事务中，对于同一份数据的读取结果总是相同的。无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决**脏读**、**不可重复读**。
> **Serializable（可串行化）：**事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的**所有问题**，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题。

## 持久性
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



# 多版本并发控制 MVCC

MVCC（Mutil-Version Concurrency Control）是一种多版本并发控制机制，是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现**读已提交**和**可重复读**这两种隔离级别。MVCC 是通过**保存**数据在某个时间点的**快照**来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的**创建版本号**和**删除版本号**，然后 Innodb 的 MVCC 使用到的**快照存储在 Undo 日志**中，该日志通过回滚指针把一个数据行所有快照连接起来。

MVCC 机制是解决**行级锁的大量开销**，使用版本控制达到**读写不冲突**，**读不加锁**和**高并发**。对于写操作只锁定必要的行。

**Select（快照读，所谓读快照就是读取当前事务之前的数据。）**
InnoDB 只 select 查找版本号早于当前版本号的数据行

- **一致性读 （就是读取快照）**select * from table ....
- **当前读 (就是读取实际的持久化的数据) **特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。select * from table where ? lock in share mode; select * from table where ? for update; insert; update ; delete;
  使用的是 next-key 锁：包含记录锁 record lock 和间隙锁 gap lock。
  记录锁是加在索引上的锁，间隙锁是加在索引之间的。一般等值查询加的是记录锁，区间查询加的是间隙锁。

**InnoDB 的 RR 隔离级别没有完全避免幻读现象，那么如何解决幻读呢？**
(首先可以说一下什么情况下会产生幻读。)
在使用的 select ...where 语句中加入 for update (排他锁) 或者 lock in share mode (共享锁)语句来实现，在所查找的数据不存在的情况下加的是间隙锁，再配合插入意向锁。**其实就是锁住了可能造成幻读的数据，阻止数据的写入操作。**

**加入间隙锁和插入意向锁可以解决幻读现象，但是会导致死锁的产生，那么如何解决死锁？**

# 死锁

## 死锁解决

1.超时事务回滚。

2.死锁检测，检测开销比较小的事务让其牺牲回滚。

## 如何避免死锁

1.以固定的顺序访问表和行。像上面的循环死锁就是这么产生的。

2.大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小；

3.在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率；

4.降低隔离级别。比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

5.为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。



# Innodb

InnoDB 是一个**事务型**的存储引擎，有**行级锁定**和**外键约束**。
Innodb 引擎提供了对数据库**ACID 事务**的支持，并且实现了 SQL 标准的四种**隔离级别**。该引擎还提供了**行级锁**和**外键约束**，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL 后台的完整数据库系统，MySQL 运行时 Innodb 会在内存中建立**缓冲池**，用于**缓冲数据和索引**。但是该引擎不支持 **FULLTEXT** 类型的索引，而且它**没有保存表的行数**，当`SELECT COUNT(*) FROM TABLE`时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用 Innodb 引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表



