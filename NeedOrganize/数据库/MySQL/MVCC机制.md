# 多版本并发控制 MVCC

MVCC（Mutil-Version Concurrency Control）是一种多版本并发控制机制，是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现**读已提交**和**可重复读**这两种隔离级别。MVCC 是通过**保存**数据在某个时间点的**快照**来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的**创建版本号**和**删除版本号**，然后 Innodb 的 MVCC 使用到的**快照存储在 Undo 日志**中，该日志通过回滚指针把一个数据行所有快照连接起来。

MVCC 机制是解决**行级锁的大量开销**，使用版本控制达到**读写不冲突**，**读不加锁**和**高并发**。对于写操作只锁定必要的行。

**Select（快照读，所谓读快照就是读取当前事务之前的数据。）**
InnoDB 只 select 查找版本号早于当前版本号的数据行

- **一致性读 （就是读取快照）**select * from table ....
- **当前读(就是读取实际的持久化的数据)**特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。select * from table where ? lock in share mode; select * from table where ? for update; insert; update ; delete;

**InnoDB 的 RR 隔离级别没有完全避免幻读现象，那么如何解决幻读呢？**
(首先可以说一下什么情况下会产生幻读。)
在使用的 select ...where 语句中加入 for update (排他锁) 或者 lock in share mode (共享锁)语句来实现，在所查找的数据不存在的情况下加的是间隙锁，再配合插入意向锁。**其实就是锁住了可能造成幻读的数据，阻止数据的写入操作。**

**加入间隙锁和插入意向锁可以解决幻读现象，但是会导致死锁的产生，那么如何解决死锁？**

# 死锁

## 死锁解决

1.超时事务回滚。

2.死锁检测，检测开销比较小的事务让其牺牲回滚。

## 如何避免死锁

1.以固定的顺序访问表和行。像上面的循环死锁就是这么产生的。

2.大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小；

3.在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率；

4.降低隔离级别。比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

5.为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

