# ==C++程序编译的阶段==

对于 C++源文件，从文本到可执行文件一般需要四个过程： 

1. **预处理阶段**：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成**预编译文件**（`.i`或`.ii`文件）
2. **编译阶段**：将经过预处理后的预编译文件转换成特定汇编代码，生成**汇编文件**（`.s`文件） 
3. **汇编阶段**：将编译阶段生成的汇编文件转化成机器码，生成**可重定位目标文件**（`.o`文件）
4. **链接阶段**：将多个目标文件及所需要的库连接成最终的**可执行目标文件**（.out文件）

| 平台       | 可执行文件 | 目标文件 | 动态库/共享对象       | 静态库       |
| ---------- | ---------- | -------- | --------------------- | ------------ |
| Windows    | exe        | obj      | dll                   | lib          |
| Unix/Linux | ELF、out   | o        | so                    | a            |
| Mac        | Mach-O     | o        | dylib、tbd、framework | a、framework |

# ==静态链接和动态链接==

## 静态链接

###  为什么要静态链接

在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个`*.c`文件会形成一个`*.o`文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接。

### 静态链接的原理

由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件，如下图，使用ar命令的-a参数查看静态库的组成：

![20180505234059214](D:\notes\面试准备\C++\编译与底层.assets\20180505234059214.png)

以下面这个图来简单说明一下从静态链接到可执行文件的过程，根据在源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a中找到目标文件printf.o(这里暂且不考虑printf()函数的依赖关系)，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。

![20180505235327609](D:\notes\面试准备\C++\编译与底层.assets\20180505235327609.png)

这里有一个小问题，就是从上面的图中可以看到静态运行库里面的一个目标文件只包含一个函数，如libc.a里面的printf.o只有printf()函数，strlen.o里面只有strlen()函数。

我们知道，链接器在链接静态链接库的时候是以目标文件为单位的。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。

### 静态链接的优缺点

**优点：**

在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

**缺点：**

1. 浪费空间

   因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本。

2. 更新比较困难

   因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

## 动态链接

### 为什么会出现动态链接

动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。

### 动态链接的原理

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

下面简单介绍动态链接的过程：

假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

### 动态链接的优缺点

**优点：**

1. 节省空间

   即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本。

2. 更新方便

   更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

**缺点：**

因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

### 动态链接地址是如何重定位的呢？

前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？

虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。

## 静态链接库和动态链接库的区别

[静态链接库和动态链接库的区别](https://blog.csdn.net/hhhuang1991/article/details/80056071)

[GCC编译过程与动态链接库和静态链接库](https://www.cnblogs.com/king-lps/p/7757919.html)

# RTTI

RTTI是运行阶段类型识别（Runtime Type Identification）的简称。

RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。很多类库已经为其类对象提供了实现这种功能的方式，但由于C++内部并不支持，因此各个厂商的机制通常互不兼容。创建一种RTTI语言标准将使得未来的库能够彼此兼容。

**运行时类型检查，在 C++层面主要体现在 dynamic_cast 和 typeid，VS 中虚函数表的-1 位置存放了指向 type_info 的指针。对于存在虚函数的类型，typeid 和 dynamic_cast 都会去查询 type_info。**

## RTTI的用途

假设有一个类层次结构，其中的类都是从同一个基类派生而来的，则可以让基类指针指向其中任何一个类的对象。这样便可以调用这样的函数：在处理一些信息后，选择一个类，并创建这种类型的对象，然后返回它的地址，而该地址可以被赋给基类指针。如何知道指针指向的是哪种对象呢？

在回答这个问题之前，先考虑为何要知道类型。可能希望调用类方法的正确版本，在这种情况下，只要该函数是类层次结构中所有成员都拥有的虚函数，则并不真正需要知道对象的类型。但派生对象可能包含不是继承而来的方法，在这种情况下，只有某些类型的对象可以使用该方法。也可能是出于调试目的，想跟踪生成的对象的类型。对于后两种情况，RTTI提供解决方案。

## RTTI的工作原理

* 如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回0——空指针。

* typeid运算符返回一个指出对象的类型的值，typeid运算符返回一个对type_info对象的引用。

* type_info结构存储了有关特定类型的信息。type_info是在头文件typeinfo（以前为typeinfo.h）中定义的一个类。type_info类重载了= =和!=运算符，以便可以使用这些运算符来对类型进行比较。

  `typeid(Magnificent)==typeid(*pg)`

只能将RTTI用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生对象的地址赋给基类指针。

# 头文件

## include头文件的顺序

对于 include 的头文件来说，如果在文件 a.h 中声明一个在文件 b.h 中定义的变量，而不引用 b.h。那么要在 a.c 文件中引用 b.h 文件，并且要先引用 b.h，后引用 a.h,否则汇报变量类型未声明错误。

文件a.h：

```C++
#include<stdio.h>
Test  a_test;
```

文件b.h：

```C++
#include<string.h>
typedef struct{
	string name;
	int age;
}Test,*pTest;
```

引用a.h和b.h的.c文件：

```C++
#include<b.h>
#include<a.h>
```

错误的引用顺序：

```C++
#include<a.h>
#include<b.h>
```

## 双引号“ ”和尖括号< >的区别

编译器预处理阶段查找头文件的路径不一样。

对于使用双引号包含的头文件，查找头文件路径的顺序为： 

1. 当前头文件目录 
2. 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径） 
3. 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

对于使用尖括号包含的头文件，查找头文件的路径顺序为：

1. 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）
2. 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

# malloc的原理以及brk系统调用和mmap系统调用的作用（待整理）

Malloc 函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc 其采用内存 池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单 位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc 采用隐式链表结构将堆区 分成连续的、大小不一的块，包含已分配块和未分配块；同时 malloc 采用显示链表结构来管理 所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分 配的地址。 

当进行内存分配时，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分 配；当进行内存合并时，malloc 采用边界标记法，根据每个块的前后块是否已经分配来决定是 否进行块合并。 

Malloc 在申请内存时，一般会通过 brk 或者 mmap 系统调用进行申请。其中当申请内存小于 128K 时，会使用系统函数 brk 在堆区中分配；而当申请内存大于 128K 时，会使用系统函数 mmap 在映射区分配。

# C++内存管理（待整理）

32bitCPU 可寻址 4G 线性空间，每个进程都有各自独立的 4G 逻辑地址，其中 0~3G 是用户态空间，3~4G 是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

![image-20201126093555791](D:\notes\面试准备\C++\编译与底层.assets\image-20201126093555791.png)

在 C++中，虚拟内存分为代码段、数据段、BSS 段、堆区、文件映射区以及栈区六部分。 

静态区域：

* 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。 
* 数据段：存储程序中已初始化的全局变量和静态变量。
* bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为 0 的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行 main 之前时会统一清 零。即未初始化的全局变量编译器会初始化为 0。

动态区域：

* 堆区： 调用 new/malloc 函数时在堆区动态分配内存，同时需要调用 delete/free 来手动释放申请的内存。 当进程未调用 malloc 时是没有堆段的，只有调用 malloc 时采用分配一个堆， 并且在程序运行过程中可以动态增加堆大小(移动 break 指针)，从低地址向高地址增长。分配小 内存时使用该区域。 堆的起始地址由 mm_struct 结构体中的 start_brk 标识，结束地址由 brk 标识。
* 映射区：存储动态链接库以及调用 mmap 函数进行的文件映射。存储动态链接库等文件映射、申请大内存（malloc 时调用 mmap 函数）。
* 栈：==使用栈空间存储函数的返回地址、参数、局部变量、返回值==，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux 可以通过 ulimit 命令指定。

# 共享内存相关API（待整理）

Linux 允许不同进程访问同一个逻辑内存，提供了一组 API，头文件在 sys/shm.h 中。 

1. 新建共享内存 shmget 

   `int shmget(key_t key,size_t size,int shmflg);` 

   key：共享内存键值，可以理解为共享内存的唯一性标记。

   size：共享内存大小

   shmflag：创建进程和其他进程的读写权限标识。

   返回值：相应的共享内存标识符，失败返回-1

2. 连接共享内存到当前进程的地址空间 shmat

   `void *shmat(int shm_id,const void *shm_addr,int shmflg);`

   shm_id：共享内存标识符 

   shm_addr：指定共享内存连接到当前进程的地址，通常为 0，表示由系统来选择

   shmflg：标志位 

   返回值：指向共享内存第一个字节的指针，失败返回-1

3. 当前进程分离共享内存 shmdt

   `int shmdt(const void *shmaddr);`

4. 控制共享内存 shmctl

   和信号量的 semctl 函数类似，控制共享内存

   `int shmctl(int shm_id,int command,struct shmid_ds *buf);`

   shm_id：共享内存标识符 

   command: 有三个值

   ​	IPC_STAT:获取共享内存的状态，把共享内存的 shmid_ds 结构复制到 buf 中

   ​	IPC_SET:设置共享内存的状态，把 buf 复制到共享内存的 shmid_ds 结构

   ​	IPC_RMID:删除共享内存

   buf：共享内存管理结构体

# C++ STL的内存优化（待整理）

1. 二级配置器结构 STL 内存管理使用二级内存配置器。 

   * 第一级配置器：

     第一级配置器以 malloc()，free()，realloc()等 C 函数执行实际的内存配置、释放、重新 配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。 一级空间配置器分配的是大于 128 字节的空间 如果分配不成功，调用句柄释放一部分内存 如果还不能分配成功，抛出异常

   * 第二级配置器：

     在 STL 的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来 的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。

   * 分配原则

     如果要分配的区块大于 128bytes，则移交给第一级配置器处理。

     如果要分配的区块小于 128bytes，则以内存池管理（memory pool），又称之次层配置 （sub-allocation）：每次配置一大块内存，并维护对应的 16 个空闲链表（free-list）。下次 若有相同大小的内存需求，则直接从 free-list 中取。如果有小额区块被释放，则由配置器回收 到 free-list 中。 

     当用户申请的空间小于 128 字节时，将字节数扩展到 8 的倍数，然后在自由链表中查找对应 大小的子链表 

     如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请 20 块 

     如果内存池空间足够，则取出内存 

     如果不够分配 20 块，则分配最多的块数给自由链表，并且更新每次申请的块数 

     如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统 heap 申请空间，如果申 请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器

2. 二级内存池

   二级内存池采用了 16 个空闲链表，这里的 16 个空闲链表分别管理大小为 8、16、24......120、 128 的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲 数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中） 的地址。

   ![image-20201126100146357](D:\notes\面试准备\C++\编译与底层.assets\image-20201126100146357.png)

   * 空间配置函数 allocate

     首先先要检查申请空间的大小，如果大于 128 字节就调用第一级配置器，小于 128 字节就 检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一 个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数 据块，则调用 refill 重新填充空间。

   * 空间释放函数 deallocate

     首先先要检查释放数据块的大小，如果大于 128 字节就调用第一级配置器，小于 128 字节 则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。

   * 重新填充空闲链表 refill

     在用 allocate 配置空间时，如果空闲链表中没有可用数据块，就会调用 refill 来重新填 充空间，新的空间取自内存池。缺省取 20 个数据块，如果内存池空间不足，那么能取多少个节 点就取多少个。 

     从内存池取空间给空闲链表用是 chunk_alloc 的工作，首先根据 end_free-start_free 来 判断内存池中的剩余空间是否足以调出 nobjs 个大小为 size 的数据块出去，如果内存连一个数 据块的空间都无法供应，需要用 malloc 取堆中申请内存。 

     假如山穷水尽，整个系统的堆空间都不够用了，malloc 失败，那么 chunk_alloc 会从空闲 链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。

3. 总结：

   * 使用 allocate 向内存池请求 size 大小的内存空间，如果需要请求的内存大小大于 128bytes，直接使用 malloc。
   * 如果需要的内存大小小于 128bytes，allocate 根据 size 找到最适合的自由链表。
     * 如果链表不为空，返回第一个 node，链表头改为第二个 node。
     * 如果链表为空，使用 blockAlloc 请求分配 node。
       * 如果内存池中有大于一个 node 的空间，分配竟可能多的 node(但是最多 20 个)， 将一个 node 返回，其他的 node 添加到链表中。
       * 如果内存池只有一个 node 的空间，直接返回给用户。
       * 若果如果连一个 node 都没有，再次向操作系统请求分配内存。
         * 分配成功，再次进行 b 过程。
         * 分配失败，循环各个自由链表，寻找空间。
           * 找到空间，再次进行过程 b。
           * 找不到空间，抛出异常。
   * 用户调用 deallocate 释放内存空间，如果要求释放的内存空间大于 128bytes，直接调 用 free。
   * 否则按照其大小找到合适的自由链表，并将其插入。

# ==内存泄漏==

## 什么是内存泄漏

内存泄漏(memory leak)是指由于疏忽或错误造成了**程序未能释放掉不再使用的内存**的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，**失去了对该段内存的控制**，因而造成了内存的浪费。 

内存泄漏的分类： 

1. **堆内存泄漏（Heap leak）**。对内存指的是程序运行中根据需要分配通过 malloc,realloc new 等从堆中分配的一块内存，再是完成后必须通过调用对应的 free 或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生 Heap Leak. 
2. **系统资源泄露（Resource Leak）**。主要指程序使用系统分配的资源比如 Bitmap、handle、SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 
3. **没有将基类的析构函数定义为虚函数**。当基类指针指向子类对象时，如果基类的析构函数不是 virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

## 怎么判断内存泄漏

内存泄漏通常是由于调用了 malloc/new 等内存申请的操作，但是缺少了对应的 free/delete。 为了判断内存是否泄露，我们一方面可以使用 linux 环境下的**内存泄漏检查工具 Valgrind、mtrace**,另一方面我们在写代码时可以**添加内存申请和释放的统计功能**，统计当前申请和释放的内存是否一致， 以此来判断内存是否泄露。

# 什么时候会发生段错误

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况： 

* 使用野指针
* 试图修改字符串常量的内容

# reactor模型组成（待整理）

reactor 模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：

![image-20201126095110422](D:\notes\面试准备\C++\编译与底层.assets\image-20201126095110422.png)

1. Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer 等。由于 Reactor 模式一般使用在网络编程中，因而这里一般指 Socket Handle，即一个网络连接。 
2. Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的 Handle 中的事件到来，如果阻塞等待返回，即表示在返回的 Handle 中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的 select 来实现。
3. Initiation Dispatcher：用于管理 Event Handler，即 EventHandler 的容器，用以注 册、移除 EventHandler 等；另外，它还作为 Reactor 模式的入口调用 Synchronous Event Demultiplexer 的 select 方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的 Handle 将其分发给对应的 Event Handler 处理，即回调 EventHandler 中的 handle_event()方法。
4. Event Handler：定义事件处理方法：handle_event()，以供 InitiationDispatcher 回调使用。 
5. Concrete Event Handler：事件 EventHandler 接口，实现特定事件处理逻辑。

# 如何采用单线程的方式处理高并发（待整理）

在单线程模型中，可以采用 I/O 复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来。

# select、epoll的区别、原理、性能、限制（待整理）

## I/O多路复用

IO 复用模型在阻塞 IO 模型上多了一个 select 函数，select 函数有一个参数是文件描述符 集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文 件描述符进行处理。 

这种 IO 模型是属于阻塞的 IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的 效率比阻塞 IO 模型高效。

![image-20201126095621186](D:\notes\面试准备\C++\编译与底层.assets\image-20201126095621186.png)

IO 多路复用就是我们说的 select，poll，epoll。select/epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。它的基本原理就是 select，poll，epoll 这个 function 会 不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。 

当用户进程调用了 select，那么整个进程会被 block，而同时，kernel 会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再 调用 read 操作，将数据从 kernel 拷贝到用户进程。

所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文 件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。 

I/O 多路复用和阻塞 I/O 其实并没有太大的不同，事实上，还更差一些。因为这里需要使用 两个 system call (select 和 recvfrom)，而 blocking IO 只调用了一个 system call (recvfrom)。 但是，用 select 的优势在于它可以同时处理多个 connection。 

所以，如果处理的连接数不是很高的话，使用 select/epoll 的 web server 不一定比使用 multi-threading + blocking IO 的 web server 性能更好，可能延迟还更大。select/epoll 的 优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 

在 IO multiplexing Model 中，实际中，对于每一个 socket，一般都设置成为 non-blocking， 但是，如上图所示，整个用户的 process 其实是一直被 block 的。只不过 process 是被 select 这个函数 block，而不是被 socket IO 给 block。

## select

select 在使用前，先将需要监控的描述符对应的 bit 位置 1，然后将其传给 select,当有任何一个事件发生时，select 将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大。

select：是最初解决 IO 阻塞问题的方法。用结构体 fd_set 来告诉内核监听多个文件描述符， 该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定 义中。通过轮寻来查找是否有描述符要被处理。 

存在的问题： 

1. 内置数组的形式使得 select 的最大文件数受限与 FD_SIZE； 
2. 每次调用 select 前都要重新初始化描述符集，将 fd 从用户态拷贝到内核态，每次调用 select 后，都需要将 fd 从内核态拷贝到用户态； 
3. 轮询排查当文件描述符个数很多时，效率很低； 

## poll

poll：通过一个可变长度的数组解决了 select 文件描述符受限的问题。数组中元素是结构 体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只 需要拷贝一次到内核态。poll 解决了 select 重复初始化的问题。轮寻排查的问题未解决。

## epoll

epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll 采用 只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。

epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式

1. LT 模式

   LT(level triggered)是缺省的工作方式，并且同时支持 block 和 no-block socket.在这种 做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如 果你不作任何操作，内核还是会继续通知你的。

2. ET 模式

   ET(edge-triggered)是高速工作方式，只支持 no-block socket。在这种模式下，当描述符 从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且 不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为 就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一 个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成未 就绪)，内核不会发送更多的通知(only once) 

   ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作 把处理多个文件描述符的任务饿死。

3. LT 模式与 ET 模式的区别：

   LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不 立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。 

   ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立 即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。

### epoll原理

调用顺序：

```C++
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);
```

首先创建一个 epoll 对象，然后使用 epoll_ctl 对这个对象进行操作，把需要监控的描述添 加进去，这些描述如将会以 epoll_event 结构体的形式组成一颗红黑树，接着阻塞在 epoll_wait，进入大循环，当某个 fd 上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。

# 静态联编和动态联编

联编是指一个计算机程序自身彼此关联的过程，在这个联编过程中，需要确定程序中的操作调用(函数调用)与执行该操作(函数)的代码段之间的映射关系。

按照联编所进行的阶段不同，可分为静态联编和动态联编。

* 静态联编是指在编译阶段就将函数实现和函数调用关联起来。在编译阶段就必须了解所有的函数或模块执行所需要检测的信息，它对函数的选择是基于指向对象的指针（或者引用）的类型，C语言中，所有的联编都是静态联编，并且任何一种编译器都支持静态联编。
* 动态联编是指在程序执行的时候才将函数实现和函数调用关联。动态联编对函数的选择不是基于指针或者引用，而是基于对象类型，不同的对象类型将做出不同的编译结果。C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了。

# 编译期确定和运行期确定

编译期是编译器将代码和资源文件链接编译成可执行文件的过程。

运行期是运行前面编译期生成可执行的过程。

1. 常数值在编译时就确定，变量值要到运行时才确定；
2. 局部变量相对于栈基址的偏移，编译时就确定，堆空间变量的相对位置也要运行时才确定；
3. 静态变量在用户空间的地址【虚拟地址】编译时就确定，而非静态变量运行时才确定；
4. 非虚函数的执行编译时就确定，而虚函数的执行运行时才确定；
5. 直接调用虚函数时，虚函数在虚表中的偏移（或索引）编译时就确定，而通过函数指针调用虚函数时，这个索引值运行时才确定。

# ==函数栈==

**栈帧**也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。

首先应该明白，栈是从高地址向低地址延伸的。每一次函数的调用，都会在`调用栈`（call stack）上维护一个独立的`栈帧`（stack frame），这个栈帧中维持着所需要的各种信息，一般包括：函数的返回地址和参数、临时变量（包括函数的非静态局部变量以及编译器自动生成的其他临时变量）和函数的上下文。寄存器ebp指向当前的栈帧的底部（高地址），我们称为栈底指针，寄存器esp指向当前的栈帧的顶部（低地址），我们称为栈顶指针。

**栈帧**就是利用`EBP`（栈帧指针，**请注意不是ESP**）寄存器访问局部变量、参数、函数返回地址等的手段。

寄存器：

EAX：累加(Accumulator)寄存器，常用于函数返回值

EBX：基址(Base)寄存器，以它为基址访问内存

ECX：计数器(Counter)寄存器，常用作字符串和循环操作中的计数器

EDX：数据(Data)寄存器，常用于乘除法和I/O指针

ESI：源变址寄存器

DSI：目的变址寄存器

ESP：堆栈(Stack)指针寄存器，指向堆栈顶部

EBP：基址指针寄存器，指向当前堆栈底部

EIP：指令寄存器，指向下一条指令的地址

```assembly
;栈帧结构
PUSH EBP			;函数开始（使用EBP前先把已有值保存到栈中）
MOV EBP, ESP		;保存当前ESP到EBP中

...					;函数体
					;无论ESP值如何变化，EBP都保持不变，可以安全访问函数的局部变量、参数
					
MOV ESP, EBP		;将函数的起始地址返回到ESP中
POP EBP				;函数返回前弹出保存在栈中的值
RETN				;函数终止
```

一个很常见的栈帧：

![20190812082727781](D:\notes\面试准备\C++\编译与底层.assets\20190812082727781.png)

[【C语言】函数运行过程-----栈帧调用_菜鸟成长记-CSDN博客](https://blog.csdn.net/wenqiang1208/article/details/74353303?utm_medium=distribute.pc_relevant.none-task-blog-title-6&spm=1001.2101.3001.4242)

```C++
#include <stdio.h>

int foo(int x, int y)
{
    int z;
    z = x + y;
    return z;
}

int main(int argc, char* argv[])
{
    int a;
    a = foo(5, 6);
}
```

汇编代码：

```assembly
push	6
push	5	#参数从右到左入栈
call	foo	#call指令的调用，先将call指令下一条指令地址压栈保存，然后跳转到foo函数的地方

push	ebp #ebp压栈，保存指向main()函数栈帧底部的地址，方便之后恢复现场
mov		ebp,esp #将esp的值赋给ebp
sub		esp,0CCh#抬高栈顶，为add()函数预开辟空间
push	ebx	#基址寄存器压栈
push	esi	#目的变址寄存器压栈
push	edi	#EDI压栈
lea		edi,[ebp-0CCh]  #取偏移地址给EDI
mov		ecx,33h	#计数寄存器为33h
mov		eax,0CCCCCCCCh	#累加寄存器为0xcccccccc
rep stos	dword ptr es:[edi]	#将栈上从ebp-0xcc开始的位置向高地址方向的内存赋值0xCCCCCCCC,次数重复0x33(51)次. 注意0xCCCCCCCC代表着未被初始化.
mov		ecx,offset _88DDAB50_test@cpp (010C003h)  
call	@__CheckForDebuggerJustMyCode@4 (010121Ch)  
...
mov		eax,dword ptr [x]	#x给累加寄存器
add		eax,dword ptr [y]	#EAX和y相加结果存储在EAX中
mov		dword ptr [z],eax	#将EAX的值给z
mov		eax,dword ptr [z]	#将结果存在EAX中，通过EAX返回函数值
pop		edi	#EDI出栈
pop		esi	#ESI出栈
pop		ebx	#EBX出栈
mov		esp,ebp	#esp指向ebp指向的地方
pop		ebp	#main-ebp出栈，回到main函数的栈帧
ret	#pop返回地址，jmp返回地址，返回到call foo的下一条指令继续执行

add		esp,8  #esp向下，即恢复到5和6入栈之前的样子
mov		dword ptr [a],eax  #把返回值给a
```

![23dc52309585d6404517e6d8a76fd581](D:\notes\面试准备\C++\编译与底层.assets\23dc52309585d6404517e6d8a76fd581.png)

![e84ee7ee886306ebfb4282cb315445cf](D:\notes\面试准备\C++\编译与底层.assets\e84ee7ee886306ebfb4282cb315445cf.png)

![6b5539e80380aae9c246445ed7f829f3](D:\notes\面试准备\C++\编译与底层.assets\6b5539e80380aae9c246445ed7f829f3.png)

![image-20201207161412474](D:\notes\面试准备\C++\编译与底层.assets\image-20201207161412474.png)

# ==垃圾回收机制==

## 原理

### 垃圾判断算法

#### 引用计数法

给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：**无法解决循环引用的问题**。

#### 可达性分析算法

通过`GC ROOT`的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为`GC ROOT`的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中`JNI`引用的对象）

![2269232-97bf646f648d6ff7](D:\notes\面试准备\C++\编译与底层.assets\2269232-97bf646f648d6ff7.webp)

通过可达性算法，成功解决了引用计数所无法解决的循环依赖问题，只要你无法与`GC Root`建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于GC Root。

Java内存区域中可以作为`GC ROOT`的对象：

* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中引用的对象

### 垃圾回收算法

#### 标记-清除法

![2269232-5b023b00f7bf8f1b](D:\notes\面试准备\C++\编译与底层.assets\2269232-5b023b00f7bf8f1b.webp)

标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。但它存在一个很大的问题，那就是**内存碎片**。

上图中等方块的假设是2M，小一些的是1M，大一些的是4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个2M的内存区域，其中有2个1M是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。

#### 复制算法

![2269232-46c30f2ffb8c18af](D:\notes\面试准备\C++\编译与底层.assets\2269232-46c30f2ffb8c18af.webp)

复制算法（Copying）是在标记清除算法基础上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。复制算法暴露了另一个问题，例如硬盘本来有500G，但却只能用200G，代价实在太高。

#### 标记-整理算法

![2269232-d7cb73cb0e50c060](D:\notes\面试准备\C++\编译与底层.assets\2269232-d7cb73cb0e50c060.webp)

标记-整理算法标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。

标记整理算法解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。标记整理算法对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。一般是把Java堆分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。

#### 分代收集算法

分代收集算法分代收集算法严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳，根据对象存活周期的不同将内存划分为几块。

- 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。
- 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记-清理算法**或者**标记-整理算法**来进行回收。

## 为什么C++没有垃圾回收机制

1. 没有共同基类

   C++是从C发展而成，同意直接操作指针，同意将一个类型转换为还有一个类型，对于一个指针无法知道它真正指向的类型；而Java或C#都有一个共同基类。

2. 系统开销

   垃圾回收所带来的系统开销，不符合C++高效的特性，使得不适合做底层工作。

3. 耗内存

   C++产生的年代内存非常少，垃圾回收机制须要占用很多其它的内存。

4. 替代方法

   C++有析构函数、智能指针、引用计数去管理资源的释放，对GC的需求不迫切。

# ==C++函数调用约定==

**调用惯例**是`调用方`和`被调用方`对于函数如何调用的一个明确的约定，只有双方都遵守同样的约定，函数才能被正确地调用。

函数调用约定决定函数参数入栈的顺序，以及由调用者函数还是被调用函数负责清除栈中的参数等问题，而函数名修饰规则决定编译器使用何种名字修饰方式来区分不同的函数，如果函数之间的调用约定不匹配或者名字修饰不匹配就会产生以上的问题。

C++语言中的函数调用约定主要针对三个问题：

* 函数参数的传递顺序和方式

  函数参数的传递方式有很多种方式，`最常见`的一种是`通过栈`传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：是从左至右，还是从右至左。有些调用惯例还允许`使用寄存器`传递参数，以`提高性能`。

* 清理栈的主体（负责清理栈的主体：函数自身还是函数调用者）

  在函数将参数压栈之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数体本身来完成。

* 函数名称重整

  为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。
  
  在C++中，为了允许操作符重载和函数重载，C++编译器通常按照某种规则改写每一个入口点的符号名，以便允许同一个名字（具有不同的参数类型或者是不同的作用域）有多个用法，而不会打破现有的基于C的链接器。这项技术通常被称为名称改编（Name Mangling）或者名称修饰（Name Decoration）。C++编译器厂商通常选择自己的名称修饰方案。
  

调用约定主要是指函数被调用的方式，C++的函数调用约定主要有stdcall、fastcall、pascal、cdecl、thiscall等约定。

例：

【code1】

```C++
void function();
int add(int a,int b);
```

以上是大家所熟知的构成部分，其实函数的构成还有一部分，那就是调用约定。如下：

【code2】

```C++
void __cdecl function();
int __stdcall add(int a,int b);
```

上面的__cdecl和__stdcall就是调用约定，其中__cdecl是C和C++默认的调用约定，所以通常我们的代码都如 【code1】中那样定义，编译器默认会为我们使用__cdecl调用约定。

## 函数的调用过程

要深入理解函数调用约定，你须要了解函数的调用过程和调用细节。
如下面的代码，ShowResult为调用者，add为被调用者。

```C++
int add(int a,int b) {
    return a+b;
}

void ShowResult() {
    cout<<add(5,10)<<endl;
}
```

函数调用过程可以这么描述：
（1）先将调用者（A）的堆栈的基址（ebp）入栈，以保存之前任务的信息。
（2）然后将调用者（A）的栈顶指针（esp）的值赋给ebp，作为新的基址（即被调用者B的栈底）。
（3）然后在这个基址（被调用者B的栈底）上开辟（一般用sub指令）相应的空间用作被调用者B的栈空间。
（4）函数B返回后，从当前栈帧的ebp即恢复为调用者A的栈顶（esp），使栈顶恢复函数B被调用前的位置；然后调用者A再从恢复后的栈顶可弹出之前的ebp值（可以这么做是因为这个值在函数调用前一步被压入堆栈）。这样，ebp和esp就都恢复了调用函数B前的位置，也就是栈恢复函数B调用前的状态。

## C++常见函数调用约定

1. __stdcall

   `__stdcall`是StandardCall的缩写，是C++的标准调用方式。`__stdcall`调用约定的规则如下：

   * 所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针
   * 被调用函数自动清理堆栈，返回值在EAX
   * 函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上"@"和参数的字节数

2. __cdecl

   `__cdecl`是C DECLaration的缩写（declaration，声明），表示C语言默认的函数调用方法。`__cdecl`调用约定规则如下：

   * 所有参数从右到左依次入栈
   * 所有参数由调用者清除，称为手动清栈。返回值在EAX中
   * 函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀

   由于由调用者清理栈，所以允许可变参数函数存在，如int sprintf(char buffer, const char format,...)。

3. __fastcall

   `__fastcall`是快速调用约定，通过寄存器来传送参数。`__fastcall`调用约定的规则如下：

   * 用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数依旧自右向左压栈传送
   * 被调用函数在返回前清理传送参数的内存栈，返回值在EAX中
   * 函数修饰名约定：VC将函数编译后会在函数名前面加上"@"前缀，在函数名后加上“@”和参数的字节数

4. thiscall

   `thiscall`是唯一一个不能明确指明的函数修饰符，thiscall只能用于C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理。

   thiscall调用约定如下：

   * 采用栈传递参数，参数从右向左入栈。如果参数个数确定，this指针通过ECX传递给被调用者；如果函数参数个数不确定，this指针所在的所有参数压栈后被压入堆栈。
   * 对参数个数不定的，调用者清理堆栈，否则由被调函数清理堆栈。

   thiscall不是关键字，程序员不能使用。