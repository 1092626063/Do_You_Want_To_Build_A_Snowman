# ==面向对象的特点==

## 封装

封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

## 继承

实现代码的重用，相同的代码不需要重复的写。

## 多态

指的是子类对象可以赋值给父类变量，但运行是仍表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可以表现出多种行为特征。

# ==面向对象的六大基本原则==

1. 单一职责原则

   **单一职责原则是指一个类的功能要单一**，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。说白了就是，一个类中是一组相关性和高的函数，一个类尽量只实现一个功能。

2. 开放封闭原则OCP(Open-Close Principle)

   **一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的**。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

3. 里氏替换原则LSP(the Liskov Substitution Principle)

   子类应当可以替换父类并出现在父类能够出现的任何地方。（比如父类public，子类一定是public）

4. 依赖倒置原则DIP(the Dependency Inversion Principle)

   **A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。**

   **B.抽象不应该依赖于具体实现，具体实现应该依赖于抽象。**

   具体依赖抽象。高层模块就是调用端，底层模块就是具体实现类。（应该让底层模块定义抽象接口并且实现，让高层模块调用抽象接口，而不是直接调用实现类。）

   通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。

   问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。

   解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。（比如A依赖于车的轮胎，速度，牌子等接口，然后让B，C直接实现这些接口的方法，A间接通过接口与BC发生联系。）

   好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。

5. 接口分离原则ISP(the Interface Segregation Principle)

   模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来，即面向接口编程。（提供接口，给其他模块调用）

   **核心思想：类间的依赖关系应该建立在最小的接口上。**

   **通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。**

   也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

   问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类C来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

   需注意：接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。

6. 迪米特法则(Law of Demeter)

   **核心思想：类间解耦。**

   通俗来讲：**一个类对自己依赖的类知道的越少越好。一个对象应该对其他对象保持最少的了解。**自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。

   耦合是：

   简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。

   有软硬件之间的耦合，还有软件各模块之间的耦合。
   耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。

   耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：

   - 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。
   - 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。
   - 外部耦合。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。
   - 控制耦合。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。
   - 标记耦合。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。
   - 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。
   - 非直接耦合。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。

# ==C++多态==

多态的意思就是多种形态，相同的方法调用，但是有不同的实现方式。

> “一个接口，多种方法”。

## 静态多态

编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型，可推断出要调用哪个函数，如果有对应的函数就调用该函数，否则出现编译错误。

静态多态的两种实现方式：

* 函数重载
* 函数模板

> 为什么C语言中没有重载呢？
>
> 就算函数的调用约定都是`_cdecl`，但是由于函数在内存中的存储方式不相同，C语言是`“_” + 函数名`形式，而C++是`?函数名@@YA返回值 参数@Z`形式。

## 动态多态

运行时的多态，在程序执行期间（非编译期）判断所引用对象的实际类型，根据其实际类型调用相应的方法。

### 动态绑定

1. 通过基类类型的引用或者指针调用虚函数

   首先搞清楚这个对象的类型：

   * 静态类型：对象声明时的类型，编译时确定
   * 动态类型：目前所指对象的类型，运行时确定

   ```C++
   class CDerived1:public CBase{
   };
   class CDerived2:public CBase{
   };
   int main(){
       CDerived1* pD1=new CDerived1;	//pD1的静态类型是CDerived1，动态类型也是
       CBase* pBase=pD1;	//pBase的静态类型是CBase*，动态类型是CDerived1*
       CDerived2* pD2=new CDerived2;
       pBase=pD2;	//pBase的动态类型现在是CDerived2
   }
   ```

2. 必须是虚函数（派生类一定要重写基类中的虚函数）

   ```C++
   class Base
   {   
   public :
       virtual void FunTest1( int _iTest){cout <<"Base::FunTest1()" << endl;}
   };
   class Derived : public Base
   {
   public :
       void FunTest1( int _iTest){cout <<"Derived ::FunTest1()" << endl;}
   }
   ```

   ==基类的构造函数不能是虚函数的原因：==

   * 若构造函数是虚函数，则需要通过虚函数表来调用，若对象还未实例化，无法找到虚函数表。
   * 在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

   ==基类的析构函数可以是虚函数的原因（为什么析构函数必须是虚函数？为什么 C++默认的析构函数不是虚函数）：==

   ```C++
   #include <iostream>
   class TestFather{
   public:
       virtual ~TestFather() {
           std::cout << "~TestFather()" << std::endl;
       }
   };
   class TestChild : public TestFather {
   public:
       ~TestChild() {
           std::cout << "~TestChild()" << std::endl;
       }
   };
   
   
   int main() {
       TestFather* p = new TestChild();
       delete p;
   }
   
   //执行结果
   //~TestChild()
   //~TestFather()
   ```

   基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor，这也说明**基类的析构函数最好写成虚函数**。

   在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。

   将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。 

   C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的 析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

   ==虚函数不可以是内联函数的原因：==
   
* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
  
- 内联是在编译期建议编译期内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
   - inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
   
   例：
   
   ```C++
   #include <iostream>
   using namespace std;
   // 基类
   class Base{
   public:
       inline virtual void who(){
           cout << "I am Base\n";
       }
       
       virtual ~Base(){}
   };
   // 派生类
   class Derived:public Base{
   public:
       inline void who(){   // 不写inline时隐式内联
           cout << "I am Derived\n";
       }
   };
   int main(){
   	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。
   	Base b;
   	b.who();
   	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。
   	Base *bptr = new Derived();
   	bptr->who();
   	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
   	delete bptr;
   	bptr = nullptr;
   	return 0;
   }
   ```

### 纯虚函数

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加`=0`。

包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。纯虚函数在派生类中重新定义以后，派生类才能实例化出对象。

```C++
#include <iostream>
#include <cstdlib>
#include <cstdio>

using namespace std;


class abstractcls
{
public:
    abstractcls(float speed,int total)   //构造函数
    {
        this->speed = speed;
        this->total = total;
    }

    virtual void showmember()= 0;    //纯虚函数的定义
protected:
    float speed;
    int total;
};

class car : public abstractcls
{
public:
    car(int aird,float speed,int total):abstractcls(speed,total)
    {
        this->aird = aird;
    }

    virtual void showmember()
    {
        cout << speed <<"--------" <<total <<"-----------"<<aird<<endl;
    }
protected:
    int aird;
};
int main()
{
    car b(250,150,4);
    b.showmember();
    return 0;
}
```

如果有很多类都继承了这个基类，那么每个对象中都要为其创建基类消耗资源，此时出现了虚函数表。

```C++
#include <iostream>
using namespace std;
class A
{
public:
    int i;
    virtual void func() {}
    virtual void func2() {}
};
class B : public A
{
    int j;
    void func() {}
};
int main()
{
    cout << sizeof(A) << ", " << sizeof(B);  //输出 8,12
    return 0;
}
```

如果将程序中的 virtual 关键字去掉，输出结果变为：`4, 8`。

## 多态的原理

### 虚函数表

```C++
//计算sizeof(b)为多少？？？
#include<iostream>
#include <stdlib.h>
using namespace std;

class Base
{
public:
	virtual void Fun1(){
		cout << "Func1()" << endl;
	}
private:
	int _b = 1;
};

int main()
{
	Base b;
	cout << "sizeof(b):" << sizeof(b) << endl;
	system("pause");
	return 0;
}
```

![image-20201128125348237](D:\notes\面试准备\C++\多态.assets\image-20201128125348237.png)

通过测试我们发现sizeof(Base)大小为8字节。**除了_b成员，还多了一个_vfptr放在对象的前面（注意有些平台可能会放在对象的后面，这个跟平台有关），对象中的这个指针我们称它为虚函数表指针**。一个含有虚函数的类中至少都有一个**虚函数表指针**，因为虚函数的地址要被放到**虚函数表（虚表）**中。

虚函数表的创建分为两种情况：

* 无覆盖

  基类中虚函数在派生类中不是虚函数

  ```C++
  class Base
  {
      virtual void fun1();
      virtual void fun2();
      virtual void fun3();
  }
  class Derived : public Base
  {
      virtual void fun4();
      virtual void fun5();
      virtual void fun6();
  }
  ```

  ![image-20201128125407624](D:\notes\面试准备\C++\多态.assets\image-20201128125407624.png)

  虚函数按声明顺序存在虚表中；在派生类中，前面是基类的虚函数，后面是派生类的虚函数。

* 有覆盖

  ```C++
  class Base
  {
      virtual void fun1();
      virtual void fun2();
      virtual void fun3();
  }
  class Derived : public Base
  {
      virtual void fun2();
      virtual void fun3();
      virtual void fun4();
  }
  ```

  派生类的函数表没有变化：

  ![image-20201128125632824](D:\notes\面试准备\C++\多态.assets\image-20201128125632824.png)

  派生类先拷贝基类的函数表，如果派生类重写了基类的某个虚函数，就用派生类的虚函数替换虚表同位置的基类虚函数，跟上派生类自己的虚函数。

**总结：派生类的虚表生成：**

1. 先将基类中的虚表内容拷贝一份到派生类虚表中；
2. 如果派生类重写了基类中的某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数；
3. 派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类的虚表的最后。

总之，调用基类的引用或指针调用，调用基类还是派生类的虚函数，要根据运行时的指针或引用实际指向或引用的类型确定，调用非虚函数时，则无论基类指向的是何种类型，都调用基类的函数。

多态的函数调用语句被编译成根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的一系列指令。

多态机制能够提高程序的开发效率，但是也增加了程序运行时的开销。虚函数表、各个对象中包含的 4 个字节的虚函数表的地址都是空间上的额外开销；而查虚函数表的过程则是时间上的额外开销。

#### 虚函数表确定时期

编译期。

在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或替换之。由于程序执行时，表格的大小和内容都不会改变，所以其建构和存取皆可以由编译器完全掌控，不需要执行期的任何介入。

可以这样理解，其实不管有多少类的对象，虚函数表就这么固定的几个，是与类的种类个数相同的（所以说相同类所有对象共享的虚函数表），因为是固定的东西，那么在编译的时候产生就可以了，而多态的实现是通过对象中的虚表指针指向不同的虚函数表实现的，在运行的时候指针指向是可以有变化的，所以需要在程序运行的时候变化！

虚函数表存放在linux是放在.rodata中，即只读数据段。windows中放在常量区。

