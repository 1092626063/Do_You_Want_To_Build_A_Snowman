指针和数组基本等价的原因在于指针算术（pointer arithmetic）和C++内部处理数组的方式。

```C++
double wages[3]={10000.0, 20000.0, 30000.0};
short stacks[3]={3, 2, 1};
double* pw=wages;
short* ps=&stacks[0];
cout<<sizeof(wages)<<endl;	//24
cout<<sizeof(pw)<<endl;	//4
```

在多数情况下，C++将数组名解释为数组第1个元素的地址。

`wages=&wages[0]=address of first element of array`

现在来看一看数组表达式stacks[1]。C++编译器将该表达式看作是*（stacks + 1），这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。

> 指针名和数组名的区别：
>
> * 可以修改指针的值，而数组名是常量
> * 对数组应用sizeof运算符得到的是数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。这种情况下，C++不会将数组名解释为地址。

> 对数组取地址时，数组名也不会被解释为其地址。等等，数组名难道不被解释为数组的地址吗？不完全如此：数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址：
>
> ```C++
> short tell[10];	//tell an array of 20 bytes
> cout<<tell<<endl;	//displays &tell[0]
> cout<<&tell<<endl;	//displays address of whole array
> ```
>
> 从数字上说，这两个地址相同；但从概念上说，&tell[0]（即tell）是一个2字节内存块的地址，而&tell是一个20字节内存块的地址。因此，表达式tell + 1将地址值加2，而表达式&tell + 1将地址加20。换句话说，tell是一个short指针（* short），而&tell是一个这样的指针，即指向包含20个元素的short数组（short (*) [20]）。
>
> ```C++
> short (*pas)[20]=&tell;	//pas points to array of 20 shorts
> ```
>
> 如果省略括号，优先级规则将使得pas先与[20]结合，导致pas是一个short指针数组，它包含20个元素，因此括号是必不可少的。其次，如果要描述变量的类型，可将声明中的变量名删除。因此，pas的类型为`short (*) [20]`。另外，由于pas被设置为&tell，因此`*pas`与tell等价，所以`(*pas) [0]`为tell数组的第一个元素。

# 4.8.2 指针小结

## 对指针解除引用

对指针解除引用意味着获得指针指向的值。

## 指针算术

C++允许将指针和整数相加。

加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。

## 数组的动态联编和静态联编

使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置：

```C++
int tacos[10];	//static binding, size fixed at compile time
```

使用new[]运算符创建数组时，将采用动态联编（动态数组），即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用delete []释放其占用的内存。

# 4.8.3 指针和字符串

```C++
char flower[10]="rose";
cout<<flower<<"s are red\n";
```

数组名是第一个元素的地址，因此cout语句中的flower是包含字符r的char元素的地址。cout对象认为char的地址是字符串的地址，因此它打印该地址处的字符，然后继续打印后面的字符，直到遇到空字符（\0）为止。

表达式“s are red\n”是什么呢？为了与cout对字符串输出的处理保持一致，这个用引号括起的字符串也应当是一个地址。在C++中，用引号括起的字符串像数组名一样，也是第一个元素的地址。

```C++
char animal[20]="bear";
const char* bird="wren";
char *ps;
//cout<<ps<<"\n";	//may display garbage, may cause a crash
//cin>>ps;	//Too horrible a blunder to try; ps dosen't point to allocated space
```

“wren”实际表示的是字符串的地址，因此这条语句将“wren”的地址赋给了bird指针。（一般来说，编译器在内存留出一些空间，以存储程序源代码中所有用引号括起的字符串，并将每个被存储的字符串与其地址关联起来。）

字符串字面值是常量，这就是为什么代码在声明中使用关键字const的原因。

使用bird来进行输入并不合适：

* 有些编译器将字符串字面值视为只读常量，如果试图修改它们，将导致运行阶段错误。在C++中，字符串字面值都将被视为常量，但并不是所有的编译器都对以前的行为做了这样的修改。
* 有些编译器只使用字符串字面值的一个副本来表示程序中所有的该字面值。

下面讨论一下第二点。C++不能保证字符串字面值被唯一地存储。也就是说，如果在程序中多次使用了字符串字面值“wren”，则编译器将可能存储该字符串的多个副本，也可能只存储一个副本。如果是后面一种情况，则将bird设置为指向一个“wren”，将使它只是指向该字符串的唯一一个副本。将值读入一个字符串可能会影响被认为是独立的、位于其他地方的字符串。无论如何，由于bird指针被声明为const，因此编译器将禁止改变bird指向的位置中的内容。

请不要使用字符串常量或未被初始化的指针来接收输入。

```C++
ps=animal;
//...
cout<<animal<<" at "<<(int*)animal<<endl;	//fox at 0x0065fd30
cout<<ps<<" at "<<(int*)ps<<endl;	//fox at 0x0065fd30
```

一般来说，如果给cout提供一个指针，它将打印地址。但如果指针的类型为char *，则cout将显示指向的字符串。如果要显示的是字符串的地址，则必须将这种指针强制转换为另一种指针类型，如int *（上面的代码就是这样做的）。

要获得字符串的副本，还需要做其他工作。首先，需要分配内存来存储该字符串，这可以通过声明另一个数组或使用new来完成。后一种方法使得能够根据字符串的长度来指定所需的空间：

```C++
ps=new char[strlen(animal)+1];
```

接下来，需要将animal数组中的字符串复制到新分配的空间中。将animal赋给ps是不可行的，因为这样只能修改存储在ps中的地址，从而失去程序访问新分配内存的唯一途径。需要使用库函数strcpy()：

```C++
strcpy(ps,animal);
```

注意，类似下面这样的代码可能导致问题，因为food数组比字符串小：

```C++
char food[20]="carrots";
strcpy(food, "a picnic basket filled with many goodies");
```

在这种情况下，函数将字符串中剩余的部分复制到数组后面的内存字节中，这可能会覆盖程序正在使用的其他内存。要避免这种问题，请使用strncpy()。该函数还接受第3个参数—要复制的最大字符数。然而，要注意的是，如果该函数在到达字符串结尾之前，目标内存已经用完，则它将不会添加空字符。因此，应该这样使用该函数：

```C++
strncpy(food, "a picnic basket filled with many goodies", 19);
food[19]='\0';
```

# 4.8.4 使用new创建动态结构

```C++
char* getname();
int main() {
    char* name;
    name=getname();
    delete []name;	//memory freed, 防止后面的值污染
    
    name=getname();
    delete []name;
}
char* getname() {
    char temp[80];
    cin>>temp;
    char *pn=new char[strlen(temp)+1];
    strcpy(pn,temp);
    return pn;
}
```

# 4.8.5 自动存储、静态存储和动态存储

根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。

C++11新增了第四种类型—线程存储。

## 自动存储

在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable），这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。

自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）。因此，在程序执行过程中，栈将不断地增大和缩小。

## 静态存储

静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static：

```C++
static double fee=56.50;
```

自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。

## 动态存储

new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。new和delete让您能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。与使用常规变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。



