# 内存管理

## 操作系统与C内存管理机制

### windows内存管理机制

Windows系统中的内存分配机制如下图所示：

![image-20201128194636870](D:\notes\面试准备\C++\内存管理.assets\image-20201128194636870.png)

操作系统将Physical Memory映射为连续的Virtual Memory（通过TLB），并提供了一些与Virtual Memory相关的API（VirtualAlloc, VirtualFree...）对Virtual Memory进行管理，在Virtual Memory API之上又构建了Heap Memory API（HeapAlloc...），而C的内存管理机制（malloc, free）就构建在Heap Memory API上。

使用Virtual Alloc分配内存时，每次只能分配页面大小（默认4KB）的整数倍的连续虚拟内存（但是两次连续调用所分配的内存并不一定连续）。

### Linux内存管理机制

Linux中可以借助brk或mmap函数从用户空间中申请连续内存。

![image-20201128195252809](D:\notes\面试准备\C++\内存管理.assets\image-20201128195252809.png)

通过调用brk(0)可以获取指向用户空间某一地址的指针，随后调用brk(len)可以在原指针地址的基础上移动该指针以达到申请或释放内存的目的。而mmap则是直接在用户空间中申请一块连续的空闲内存。

### ==C内存管理机制==

C/C++程序的内存布局如下：

![image-20201128195926008](D:\notes\面试准备\C++\内存管理.assets\image-20201128195926008.png)

从Code Segment到Stack的内存地址均位于用户空间中，其地址空间由低到高。其中：

* Code Segment（代码段或Text Segment）中存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误。
* Data Segment中存放已初始化的全局或静态变量。
* BSS中存放未初始化的全局或静态变量。
* Heap，堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现（brk函数也是从这里分配内存）。
* Stack，==用来存储函数调用时的临时信息，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。==在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。栈内存的申请和释放遵循LIFO（先进后出）。

#### ==堆和栈有什么不同？==

1. 分配和管理方式不同

   * 堆是动态分配的，其空间的分配和释放都由程序员控制。

   * 栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由_alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器释放，无须手工控制。

     > 1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
     > 2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
     > 3. realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
     > 4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

2. 产生碎片不同

   * 对堆来说，频繁的new/delete或者malloc/free可能会造成内存空间的不连续，造成大量的碎片，使程序效率降低。
   * 对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。

3. 增长方向不同

   * 堆由低地址向高地址增长。

   * ==栈由高地址向低地址增长。==

     > 一般情况下，栈底地址比栈顶高。
   
4. 用途

   - 栈：存放函数的参数，局部变量，临时变量，函数返回地址。由系统分配，速度快。
     堆：由程序员自己分配和释放。速度慢，容易产生内存碎片。

