# 红黑树

## ==简介==

红黑树（Red-Black Tree）是一个自平衡的二叉查找树（BST）。红黑树具有良好的效率，它可在`O(logN)`时间内完成查找、增加、删除等操作。

## ==红黑树的性质==

普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。

红黑树通过以下的性质定义自平衡：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。
5. 从任一个节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。

有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。但是，仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。如果某些路径长度过长，那么，在对这些路径上的节点进行增删查操作时，效率也会大大降低。这时候性质4和性质5的用途就凸显了，有了这两个性质作为约束，即可保证任意节点到其某个叶子节点路径最长不会超过最短路径的2倍。原因如下：

当某条路径最短时，这条路径必然是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上的红色节点数量=黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。举例说明：

![image-20201129100354847](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129100354847.png)

上图画出了从根节点M出发到其叶子节点的最长和最短路径。最长路径长度为4，最短路径长度为2，最长路径长度正好为最短路径长度的2倍。

## 红黑树操作

红黑树的基本操作和其他树形结构一样，一般都包括查找、插入、删除等操作。前面说到，红黑树是一种自平衡的二叉查找树，既然是二叉查找树的一种，那么查找过程和二叉查找树一样，比较简单，这里不再赘述。相对于查找操作，红黑树的插入和删除操作就要复杂的多。尤其是删除操作，要处理的情况比较多，不过大家如果静下心来去看，会发现其实也没想的那么难。好了，废话就说到这，接下来步入正题吧。

### 旋转操作

旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。还是请看下图：

![image-20201129101025164](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129101025164.png)

这里以右旋为例进行说明，右旋节点 M 的步骤如下：

1. 将节点 M 的左孩子引用指向节点 E 的右孩子
2. 将节点 E 的右孩子引用指向节点 M，完成旋转

![image-20201129101228760](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129101228760.png)

### 插入操作

红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？答案是红色，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。

接下来，将分析插入红色节点后红黑树的情况。这里假设要插入的节点为 N，N 的父节点为 P，祖父节点为 G，叔叔节点为 U。插入红色节点后，会出现5种情况，分别如下：

1. 插入的新节点N是红黑树的根节点，这种情况下，把节点N的颜色由红色变为黑色，性质2被满足。同时N被染成黑色后，红黑树所有路径上的黑色节点数量增加一个，性质5被满足。

   ![image-20201129101557923](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129101557923.png)

2. N的父节点是黑色，这种情况下，性质4和性质5没有受到影响，不需要调整。

   ![image-20201129101707023](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129101707023.png)

3. N的父节点是红色，叔叔节点U也是红色。由于P和N均为红色，所以性质4被打破，此时需要调整。在这种情况下，先将P和U的颜色染成黑色，再将G的颜色染成红色。此时经过G的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是G被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。

   ![image-20201129102011818](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129102011818.png)

4. N的父节点为红色，叔叔节点U为黑色。节点N是P的右孩子，且节点P是G的左孩子。此时先对P进行左旋，调整N与P的位置。接下来按照情况５进行处理，以恢复性质４。

   ![image-20201129102524806](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129102524806.png)

5. N的父节点为红色，叔叔节点U为黑色。N是P的左孩子，且P是G的左孩子。此时对G进行右旋，调整P和G的位置，并互换颜色。经过这样的调整后，性质４被恢复，同时也未破坏性质５。

   ![image-20201129102236585](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129102236585.png)

**插入总结**

上面五种情况中，情况一和情况二比较简单，情况三、四、五稍复杂。但如果细心观察，会发现这三种情况的区别在于叔叔节点的颜色，如果叔叔节点为红色，直接变色即可。如果叔叔节点为黑色，则需要选选择，再交换颜色。当把这三种情况的图画在一起就区别就比较容易观察了，如下图：

![image-20201129102822053](D:\notes\面试准备\数据结构与算法\树\红黑树.assets\image-20201129102822053.png)

