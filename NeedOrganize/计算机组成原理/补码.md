# ==为什么一个字节可以表示的有符号整数的范围是-128~+127？==

对于有符号整数的表示和具体的编程语言无关，而是由硬件决定的，我们能想到的最简单的方法就是用其中一位表示符号，剩余七位用来表示数据位。

![1459245-20200406220226924-1166219717](D:\notes\面试准备\计算机组成原理\补码.assets\1459245-20200406220226924-1166219717.png)

但这种方法有一个缺陷，就是会有+0和-0两个0，能够表示的数据只有**-127~+127，**同时使用两个位组合表示同一个数字有些浪费，**补码**很好的解决了这一问题。

## 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

[+1]原 = 0000 0001

[-1]原 = 1000 0001

## 反码

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反

[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

## 补码

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

## 为什么是-128？

(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].