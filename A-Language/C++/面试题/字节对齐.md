# 字节对齐

## 基本概念

许多计算机系统对基本数据类型合法地址做出了一些限制，要求**某种类型对象的地址必须是某个值K（通常是2，4或8）的倍数**。这种对齐限制简化了形成处理器和存储器系统之间的接口的硬件设计。对齐跟数据在内存中的位置有关。**如果一个变量的地址正好位于它长度的整数倍，它就被称作自然对齐**。比如在32位cpu下，假设一个整型变量的地址为0x0004，那它就是自然对齐的。

## ==为什么要字节对齐==

* 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

* 性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要一次访问。

  > 现在考虑一个double类型的数组(double类型为8字节对齐)， 其在内存中所处的位置如下：
  >
  > ![image-20201128194522308](D:\notes\面试准备\C++\字节对齐.assets\image-20201128194522308.png)
  >
  > 数组的首地址为2，根据原则1数组未对齐。若CPU每次从内存中为8字节整数倍的地址开始读入8字节的数据，则每次从未对齐的数组中读取一个成员都要进行两次读取操作，而从对齐的数组中读取则只需要一次读取操作，数组对齐时读取效率有较大提升（虽然现在也有很多处理器支持非对齐的读取，但是还是推荐对齐)。

## ==如何处理字节对齐==

先让我们看编译器是按照什么样的原则进行对齐的：

1. **数据类型自身的对齐值**：未指定平台上基本类型的长度。对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。
2. **结构体或者类的自身对齐值**：其成员中自身**对齐值最大**的那个值。结构体总体大小能够被对齐值最大的数据成员的对齐值整除，如不能则在后面补充字节。
3. **指定对齐值**：**#pragma pack (value)**时的指定对齐值value。
4. **数据成员、结构体和类的有效对齐值**：自身对齐值和指定对齐值中**小的那个值**。

对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而非标准数据类型按下面的原则对齐：

**数组**：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。

**联合**：按其包含的**长度最大**的数据类型对齐。

**结构体**：结构体中**每个数据类型**都要对齐。

当数据类型为结构体时，编译器可能需要在结构体字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放（对于非对齐成员需要在其前面填充一些字节，保证其在对齐位置上），结构体本身也要根据自身的有效对齐值圆整(就是**结构体总长度需要是结构体有效对齐值的整数倍**)，此时可能需要在结构末尾填充一些空间，以满足结构体整体的对齐——向结构体元素中最大的元素对齐。

通过上面的分析，对结构体进行字节对齐，我们需要知道四个值：

- 指定对齐值：代码中指定的对齐值，记为packLen；
- 默认对齐值：结构体中每个数据成员及结构体本身都有默认对齐值，记为defaultLen；
- 成员偏移量：即相对于结构体起始位置的长度，记为offset；
- 成员长度：结构体中每个数据成员的长度（注结构体成员为补齐之后的长度），记为memberLen。

及两个规则：

1. 对齐规则：`offset % vaildLen = 0`，其中vaildLen为有效对齐值`vaildLen = min(packLen, defaultLen)`；
2. 填充规则：如成员变量不遵守对齐规则，则需要对其补齐；在其前面填充一些字节保证该成员对齐。需填充的字节数记为pad。

### Linux的对齐策略

在Linux中2字节数据类型(例如short)的地址必须是2的倍数，而较大的数据类型(例如int，int *，float和double)的地址必须是4的倍数。也就是说Linux下要么2字节对齐，要么4字节对齐，没有其他格式的对齐。

### Microsoft Windows的对齐策略

在Windows中对齐要求更严——任何K字节基本对象的地址都必须是K的倍数，K=2，4，或者8。特别地，double或者long long类型数据的地址应该是8的倍数。可以看出Windows的对齐策略和Linux还是不同的。

### 更改C编译器的缺省字节对齐方式

在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：

- 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。
- 使用伪指令#pragma pack ()，取消自定义字节对齐方式。

另外，还有如下的一种方式：

- `__attribute((aligned (n)))`，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。
- `__attribute__ ((packed))`，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。

字节对齐的作用不仅是便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。

对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc也是默认4字节对齐。

## 什么时候需要设置对齐

在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样。

## ==举例==

```C++
#pragma pack(2)
struct AA {
	int a;	//长度 4 > 2 按 2 对齐；偏移量为 0；存放位置区间[0,3]
	char b;	//长度 1 < 2 按 1 对齐；偏移量为 4；存放位置区间[4]
	short c;	//长度 2 = 2 按 2 对齐；偏移量要提升到 2 的倍数 6；存放位置区间[6,7]
	char d;	//长度 1 < 2 按 1 对齐；偏移量为 7；存放位置区间[8]；共九个字节
};
//此时算上填充字节，结构体占用的总字节为9字节，又有结构体大小需要为4的整数倍，因此需要在第四个成员d后填充3个字节，可以算得结构体的总大小为12
#pragma pack()
```

```C++
struct Test
{
	char a;	//[0]
	int b;	//[4,7]
	short c;	//[8,9]
};
//此时算上填充字节，结构体占用的总字节为10字节，又有结构体大小需要为4的整数倍，因此需要在第三个成员c后填充2个字节，可以算得结构体的总大小为12
```

```C++
struct Test
{
	int b;	//[0,3]
	short c;	//[4,5]
	char a;	//[5,6]
};
//结构体的总大小为8
```

从上面的例子可以看出根据对齐原则合理安排结构体成员的顺序可以减少内存的占用。