参考链接https://www.cnblogs.com/javazhiyin/p/13839357.html

# Redis简介
Redis是高性能非关系型键值对数据库，Redis的键只能为字符串，值可以是五种数据类型：字符串、列表、集合、散列表、有序集合。
Redis的数据存放在内存中，读写速度快，每秒可以处理超过10w次读写操作。
Redis被广泛应用于缓存方向、分布式锁。Redis还支持事务，持久化等。

五种数据结构：
【string】做简单的键值对缓存
对整个字符串的其中一部分执行操作，对整数和浮点数执行自增或自减操作。
【list】存储一些列表型数据结构，类似粉丝列表、文章评论列表
从两端压入或弹出元素，对单个或多个元素进行修剪，只保留一个范围内的元素。
【set】交集、并集、差集操作
添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交、并、差集，从集合中随机获取元素。
【hash】结构化的数据，比如对象
添加、获取、移除单个键值对，检查某个键是否存在。
【zset】去重但可以排序，如获取排名前几名的用户
添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名。


# Redis应用场景
## 计数器
可以对string进行自增自减运算，从而实现计数器功能 -》 redis这种内存数据库读写性能非常高，很适合存储频繁读写的计数量。

## 缓存
将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

## 会话缓存
可以使用Redis来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。//TODO 会话缓存好想法

## 全页缓存
除基本的会话token之外，有一些插件使用redis做全页缓存，这样你就可以以最快速度加载曾经浏览过的页面。

## 查找表
例如 DNS 记录就很适合用 Redis 进行存储。-》 查找表和缓存类似，也是利用 Redis 快速的查找特性，但查找表的内容不能失效，而缓存可以失效，因为缓存不作为可靠的数据来源。

## 消息队列（发布/订阅功能）
list 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 kafka、rabbitMQ 等消息中间件。

## 分布式锁
在分布式场景下， 无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，但是 SETNX 也有陷阱，详见：单机情况https://www.jianshu.com/p/6b8b4b04f2aa 为了防止单一机器宕机，采用多台机器https://blog.csdn.net/ppvqq/article/details/46819479


# Redis常见面试题
## Redis有哪些优点
1. 读写速度快，每秒处理读写超过10w次。
2. 支持数据持久化，支持AOF和RDB两种持久化方式。
3. 支持事务，Redis的所有操作都是原子性的。
4. 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

## 为什么要用Redis/缓存
高性能：
假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘读取的，将该用户访问的数据存在缓存中，这样下一次访问的时候就可以直接从缓存中获取了，从内存中读取数据会非常快。

高并发：
当数据库的访问量非常大时，可以将部分数据放入缓存中，这样一部分请求会直接访问缓存，减小数据库的压力。

## Redis为什么这么快
1. 数据存放在内存中，类似于HashMap，查找和操作的时间复杂度都是O(1)
2. 数据结构简单，都是key-value的形式，对数据操作也简单。
3. 采用单线程，避免了很多不必要的上下文切换和资源竞争，不用考虑各种锁的问题，自然不会出现死锁导致的性能消耗。

## Redis的两种持久化
第一种：RDB（默认）按照一定的时间间隔将内存中的数据以快照的形式保存到硬盘中。
优点：
1. 持久化方式方便。
2. 性能最大化，让子进程来完成持久化写操作，主进程继续处理命令。
缺点：
1. 数据安全性低，如果持久化之间redis发生故障，则会丢失数据。所以这种方式更适合数据要求不严谨的时候。

第二种：AOF，将 Redis 执行的每个写命令记录到日志文件中，当重启 Redis 时重新将持久化的日志文件恢复数据。
优点：
1. 数据安全。
2. 即使服务中途宕机，可以通过 redis-check-aof 工具解决数据一致性问题。（即比较现在的redis数据与aof中记录的是否一致）
缺点：
1. aof文件比rdb文件大，恢复速度慢。
2. 数据集大的时候，比rdb启动效率低。

## 如何选择合适的持久化方式
一般来说可以两种持久化方式都使用，当 Redis 重启时优先使用 AOF 恢复数据。
如果可以承受数分钟以内的数据丢失，那么可以使用 RDB 持久化。
如果你只希望你的数据在服务器运行的时候存在，也可以不使用任何持久化方式。

## Redis扩容问题
1. 如果是缓存，使用一致性哈希实现动态扩容缩容。
2. 如果是作为持久化存储，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。//TODO 持久化存储扩容

## Redis过期键的删除策略
三种策略，Redis中使用了惰性过期和定期过期两种过期策略。
1. 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清理。该策略会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
2. 惰性过期：只有当访问到某一个key才去判断是否过期。该策略可以最大化得节省 CPU 资源，却对内存极不友好，极端情况下会出现大量过期key没有被再次访问，从而不会被清理，占用大量内存。
3. 定期过期：这是前两个方案的折中，每隔一定时间扫描一定数量的数据库的 expires 字典中的 key。

## Redis的内存淘汰策略
Redis 的内存淘汰策略用于处理内存不足时需要申请额外空间时，并不会影响过期的key的处理。过期策略用于处理过期的缓存数据。
1. noeviction：新写入操作直接报错。
2. allkeys-lru：在键空间中移除最近最少使用的key。（最常用的策略）
3. allkeys-random：在键空间中随机移除某个key。
4. volatile-lru：在设置了过期时间的键空间中移除最近最少使用的key。
5. volatile-random：在设置了过期时间的键空间中随机移除某个key。
6. volatile-ttl：在设置了过期时间的键空间中有更早过期时间的key优先移除。

## Redis事务特性
1. 与 Mysql 不同，Redis 事务不保证原子性，且没有回滚，事务中任意命令执行失败，其余命令仍会执行。（ps：原子性，事务中的操作要么都发生，要么都不发生。）
2. Redis 事务支持隔离性，事务是通过一个队列来实现的，队列中的命令会依次执行，不受其他客户端命令的干扰。
3. 与 Mysql 相比，Redis 事务总是具有一致性和隔离性，不具有原子性和持久性。

## 为什么 Redis 使用哈希槽，而不使用一致性哈希算法
1. Redis 集群有16384个哈希槽，每个 key 通过 CRC16 校验后对16384取模来决定放在哪个槽，集群的每个节点负责一部分哈希槽。//TODO 哈希槽

## Redis 分区
//TODO Redis 分区

## Redis 实现分布式锁
Redis 可以使用 SETNX 命令实现分布式锁，为了防止获取锁后程序出现异常，导致其他进程调用 SETNX 命令总是返回0而进入死锁状态，需要为该 key 设置一个合理的过期时间。

## 如何解决 Redis 并发竞争 key 问题
什么是并发竞争key？即多个客户端调用同时对一个key进行操作，也就存在了竞争关系，这个时候我们需要使用分布式锁。
//TODO 如何解决并发竞争
1. 使用 zookeeper
2. RedLock
RedLock 相较于单节点的优势：
- 安全特性：互斥访问，永远只有一个 Client 能拿到锁。
- 避免死锁：最终 client 都能拿到锁，即使原本锁住某些资源的 client crash 了或者出现了网络分区。
- 容错性：只要大部分 Redis 节点存活就可以正常提供服务。

## 缓存异常有哪些
1. 缓存雪崩
缓存雪崩指缓存同一时间大面积失效，造成后面的请求都会落到数据库上，造成数据库短时间内承受大量请求。
解决方案：
- 缓存数据过期时间设置为随机。
- 给每个缓存数据增加相应的缓存标记，如果缓存标记失效，则更新数据缓存。
2. 缓存穿透
缓存穿透指缓存和数据库中都没有数据，而用户不断发起请求，造成数据库压力巨增。这时的用户很可能是攻击者。
解决方案：
- 接口层增加校验，如鉴权、过滤不合规查询。
- 从缓存去不到的数，数据库也没取到，这时可以将 key-value 对写为 key-null，缓存有效期设置短点，如30s。
- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数会被这个 bitmap 拦截，从而避免对底层存储系统的查询压力。//TODO 布隆过滤器
3. 缓存击穿
缓存击穿与缓存雪崩类似，区别在于缓存击穿指并发查询同一条数据，缓存雪崩是不同数据都过期了。
解决方案：
- 设置热点数据永不过期。
- 加互斥锁。
4. 缓存预热
缓存预热指系统上线后将相关的缓存数据直接加载到缓存系统。避免用户请求时先查数据库再缓存的问题。
解决方案：
- 直接写个缓存刷新页面，上线时手工操作一下。
- 数据量不大，在项目启动时预加载。
- 定时刷新缓存。

## 如何保证缓存与数据库双写时数据的一致性
一般来说，如果系统不是严格要求缓存+数据库必须一致性，缓存可以跟数据库偶尔有不一致的情况。当然想要严格一致，可以使用读写串行化，但这会极大降低 Redis 的性能，不可取。
还有一种方式可能暂时产生不一致的情况，但发生的几率特别小，就是先更新数据库，然后再更新缓存。
![Image](/Pictures/缓存数据库双写.png)

## 假如 Redis 有1亿个 key，其中10w个 key 是以某个固定的已知前缀开始的，如何将他们全部找出来。
使用 keys 指令可以找出指定模式的 key 列表。//TODO keys指令未使用过

对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

## 使用 Redis 如何实现异步队列
使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。

## 使用 Redis 如何实现延时队列
使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。